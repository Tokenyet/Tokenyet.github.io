<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Dowenの世界]]></title>
  <subtitle><![CDATA[Love Games, Knowledge Sharing.]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://tokenyet.github.io/"/>
  <updated>2016-09-10T15:52:46.463Z</updated>
  <id>http://tokenyet.github.io/</id>
  
  <author>
    <name><![CDATA[Dowen]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[OpenGL 遊戲引擎開發日誌]]></title>
    <link href="http://tokenyet.github.io/2016/09/10/OpenGL-Development-Journal/"/>
    <id>http://tokenyet.github.io/2016/09/10/OpenGL-Development-Journal/</id>
    <published>2016-09-10T15:30:15.000Z</published>
    <updated>2016-09-10T15:52:46.463Z</updated>
    <content type="html"><![CDATA[<h2 id="本篇說明">本篇說明</h2><p>開發引擎是我用來考驗自己的方式，學習、理解並實作以往學到的各種圖學概念，並用上自己對物件導向與程式語言的熟悉度，希望能完成一個基本的如場景建置、粒子效果、物理碰撞、模組動畫…等等的功能。而更甚之希望當OpenGL或圖學界中有什麼新功能，可以在自己最熟悉的環境中依照概念實作。</p>
<p>系統環境: Windows 10<br>開發軟體: Visual Studio 2015<br>硬體設備: i7-3770 and GTX960<br>核心接口: <a href="http://www.glfw.org/" title="GLFW" target="_blank" rel="external">GLFW</a>/<a href="http://glew.sourceforge.net/" title="GLEW" target="_blank" rel="external">GLEW</a>/<a href="http://glm.g-truc.net/" title="GLM" target="_blank" rel="external">GLM</a>/<a href="http://www.assimp.org/" title="Assimp" target="_blank" rel="external">Assimp</a>/<a href="https://bitbucket.org/SpartanJ/soil2" title="SOIL2" target="_blank" rel="external">SOIL2</a><br>輔助插件: <a href="http://www.horsedrawngames.com/shader-syntax-highlighting-in-visual-studio-2013/" title="Nshader" target="_blank" rel="external">Nshader for Visual Studio 2015</a></p>
<h4 id="其他事項">其他事項</h4><p><strong> 2016/09/05 前的日誌乃日根據記憶回朔，09/05方開始打算紀錄。 </strong></p>
<a id="more"></a>
<h4 id="2016/09/10">2016/09/10</h4><p>Think&amp;Imp: 第三人稱攝影機</p>
<ol>
<li>新增滑鼠點擊與滾輪的Callback事件。</li>
<li>新增第三人稱攝影機PlayerCamera。</li>
</ol>
<p>Issue: glfw事件屬於driven式，雖然是poll check，不過沒driven到就不會觸發callback，因此在滑鼠滾輪事件上需要添加Timestamp來製作Mouse靜態Class的調整。</p>

<div class="container-outside-div">
<iframe width="560" height="315" src="https://www.youtube.com/embed/btdXzboOrGI" frameborder="0" allowfullscreen align="middle"></iframe>
</div>

<h4 id="2016/09/08">2016/09/08</h4><p>Think&amp;Imp: 地形多重材質混合</p>
<ol>
<li>新增TerrainTexturePack，包含四個顏色。</li>
<li>修改TerrainRenderer與TerrainShader配合BlendMap概念。</li>
</ol>
<p>Other: 地形利用RGB與黑色達成四個材質混合，如果利用透明度可達成五個材質，又有聞之用其他色彩數學方法可達成八材質，Unity基本支援即是八種材質地形。</p>
<p>Issue 1: 縱使單一材質地形仍須使用BlendMap。<br>Issue 2: 需要一所見及所得的編輯器比較好製作BlendMap。</p>
<img src="/images/ODJ/20160908screenshot.png" width="420">
<h4 id="2016/09/07">2016/09/07</h4><p>Think&amp;Imp: 增加草地物件與迷霧效果</p>
<ol>
<li>修改SOIL讀取圖片格式從SOIL_LOAD_RGB -&gt; SOIL_LOAD_RGBA，支援透明度。</li>
<li>修改一般Shader中遇到透明會自動discard。</li>
<li>將Texture.ID改為Texture.GetID(),C++的Readonly public variable不可信任。</li>
<li>草地運用trick: Fake Lighting，使Normal都朝上，讓光源一致。</li>
<li>將各種Shader從Renderer中拔出，將共同參數交給MasterRenderer一起設置，以免未來更改Super Shader需要從每個Renderer中逐一修改。</li>
<li>針對單一天空顏色產生遠處迷霧效果，僅光源暫時不參與迷霧效果。</li>
</ol>
<p>Question: 迷霧效果是實踐於Vertex Shader，其原理與常用的深度轉換FragCoord.z相似，是否應實踐於Fragment且改用深度轉換效果較佳，因為Vertex Shader到Fragment是Intepolate的方式產生插值，就如早期光影<a href="https://en.wikipedia.org/wiki/Gouraud_shading" target="_blank" rel="external">Gouraud Shading</a>的視覺差異。</p>
<p>Other: Terrain的迷霧密度不小心調太高導致畫面不協調。</p>
<img src="/images/ODJ/20160907screenshot.png" width="420">
<h4 id="2016/09/06">2016/09/06</h4><p>Think&amp;Imp: 增加平坦地形相關繪製功能</p>
<ol>
<li>增加Terrain物件。</li>
<li>增加TerrainRenderer利用效率較高的GL_TRIANGE_STRIP繪製地形。</li>
<li>增加TerrainShader，繼承一般Shader，擁有基本光影。</li>
</ol>
<p>Issue: 樹木物件數量繪製達500有些微Lag，至1000有明顯Lag，以後需要新增Instancing功能。</p>
<img src="/images/ODJ/20160906screenshot.png" width="420">
<h4 id="2016/09/05">2016/09/05</h4><p>Think&amp;Imp: Renderer分割責任</p>
<ol>
<li>引入Template，將Entity&lt;模組&gt;，代表任何模組都可擁有位置、旋轉等基礎參數。</li>
<li>MasterRenderer: 總繪製器，儲存使用者不同的物件Entity List。</li>
<li>LightSourceRenderer: 光源繪製，目前專門繪製PointLight的光源。</li>
<li>MeshesRenderer: 模組面集合繪製，將模組載入之所有面進行繪製。</li>
<li>Renderer: 一般的Renderer，只繪製擁有一張貼圖的物件。</li>
<li>CubeShader: 目前當作光源繪製著色器，只接受基本光源參數。</li>
<li>ModelShader: 模組用，也許未來需依照模組新增其他模組著色器，目前支援單一光源的Phong光影特效。</li>
<li>StaticShader: 僅適合單一材質物件，不過也支持光影特效。</li>
<li>優化Texture載入次數。</li>
</ol>
<p>Issue: 優化在C++中的問題<br>若Texture相同，就不重新載入，但遇到std::map跟std::unorder_map使用問題，由於std::unorder_map太難實作，故利用std::map並讓TextureModel可以互相比較來建立材質索引表。所幸TextureID OpenGL控制得很好，載入過的材質僅讓使用者維護編號，因此利用TextureModel當std::map的key可行。</p>
<img src="/images/ODJ/20160905screenshot.png" width="420">
<h4 id="2016/09/04">2016/09/04</h4><p>Think&amp;Imp: 新增著色器與不同Renderer與引入Assimp，並實作簡單光影。</p>
<ol>
<li>引入模組載入AssimpLoader，新增一組MeshRenderer與MeshShader來專門繪製模組。</li>
<li>加入Phong Model的光影特效。</li>
<li>利用Debug版Assimp載入史丹佛龍約略7秒，Release版約略1秒。</li>
</ol>
<h4 id="2016/09/03">2016/09/03</h4><p>Think&amp;Imp: 基礎架構與模組載入</p>
<ol>
<li>修改核心模組，將Keyboard、Mouse、ErrorCheck、Debug等訊息以靜態方式呼叫。</li>
<li>新增TextureModel概念，擁有BasicRenderModel及一組材質讀取。</li>
<li>加入Entity概念，Entity代表物件的位置、旋轉角、縮放…等基礎屬性。</li>
<li>實作讀取簡單obj file的ObjLoader。</li>
</ol>
<p>Issue: 模組讀取速度<br>對於讀取一個<a href="http://graphics.stanford.edu/data/3Dscanrep/dragon.gif" target="_blank" rel="external">史丹佛龍</a>來講，C++的getline實在非常緩慢，大概要一分鐘才可載入完200,000行的OBJ。思考引入Assimp。</p>
<img src="/images/ODJ/long-time-dragon.png" width="420">
<h4 id="2016/09/02">2016/09/02</h4><p>Think&amp;Imp: 基礎架構</p>
<ol>
<li>基礎四元素 Renderer, BasicRenderModel, Shader, Loader</li>
<li>Renderer: 目前專門繪製單一BasicRenderModel。</li>
<li>BasicRenderModel: 只是一個存取用的資料結構，存放VAO與繪製點數(Indices)。</li>
<li>Shader: 延伸Shader，繼承Shader介面者，代表一組特殊的著色器，未來可分為一般物件著色氣、模組著色器、地形著色器…。</li>
<li>Loader: 載入資料與創造BasicRenderModel，並且具有資源管理，管理所有VAO,VBO。</li>
</ol>
<h4 id="2016/09/01">2016/09/01</h4><p>Re-Contruct: 架構除了核心部分打掉重練。<br>Re-Target: 失敗經驗，並吸收外國專家經驗，重新架構。</p>
<h4 id="2016/08/31">2016/08/31</h4><p>Think&amp;Imp: 加入地形材質</p>
<img src="/images/ODJ/flat-terrian.png" width="420">
<h4 id="2016/08/30">2016/08/30</h4><p>Think&amp;Imp: 繪製平坦地形</p>
<ol>
<li>了解地形結構。<br>概念:</li>
</ol>
<p>Vertex:<br>0  1  2  3  4<br>5  6  7  8  9<br>10 11 12 13 14<br>15 16 17 18 19<br>20 21 22 23 24</p>
<p>Indices:<br>0   5  1   6  2   7  3   8  4   9    9   5<br>5  10  6  11  7  12  8  13  9  14   14  10<br>10 15 11  16 12  17 13  18 14  19   19  15<br>15 20 16  21 17  22 18  23 19  24</p>
<p>由於使用GL_TRIANGLE_STRIP每兩排結尾都加上一些多的Vertex，開發日誌就不多說了。</p>
<img src="/images/ODJ/flat-terrian-line.png" width="420">
<h4 id="2016/08/29">2016/08/29</h4><p>Think&amp;Imp: 繪製平面與正方體</p>
<ol>
<li>依照CCW順序，自行建構正方體的Vertex與Index。<br>Issue:</li>
<li>開發有點吃緊，許多參數如位置、旋轉…等不知如何參與。</li>
</ol>
<h4 id="2016/08/28">2016/08/28</h4><p>Issue:</p>
<ol>
<li>實作並思考後發現，對於Renderer與Shader的定義不明確。</li>
<li>Renderer依照此模式下去，只有一個而且責任非常小，將限制RenderOjbect開發。</li>
<li>Shader目前定位非常虛幻，每一個新物件必須重新實作且綁定。</li>
</ol>
<h4 id="2016/08/27">2016/08/27</h4><p>Think&amp;Imp: 繪製基本物件架構。</p>
<ol>
<li>每個基礎的可繪製物件稱為RenderObject。</li>
<li>RenderObject大致為StartUp,Shutdown,Render。</li>
<li>RenderSystem繪製RenderObject抽象的集合。</li>
<li>繼承RenderObject者可任意實作自己的繪製函式。</li>
</ol>
<h4 id="2016/08/26">2016/08/26</h4><p>Target: 依照書中所見的sb7來嘗試實作一個類似的開發環境。<br>Think&amp;Imp: 建立基礎環境。</p>
<ol>
<li>建立Core類別存放核心標頭GLFW,GLEW,GLM。</li>
<li>匯入Shader類別，提供vertex,fragment,geometry,tessellation…基礎建構功能，從檔案載入。</li>
<li>匯入Camera類別，提供基本攝影機移動。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="本篇說明">本篇說明</h2><p>開發引擎是我用來考驗自己的方式，學習、理解並實作以往學到的各種圖學概念，並用上自己對物件導向與程式語言的熟悉度，希望能完成一個基本的如場景建置、粒子效果、物理碰撞、模組動畫…等等的功能。而更甚之希望當OpenGL或圖學界中有什麼新功能，可以在自己最熟悉的環境中依照概念實作。</p>
<p>系統環境: Windows 10<br>開發軟體: Visual Studio 2015<br>硬體設備: i7-3770 and GTX960<br>核心接口: <a href="http://www.glfw.org/" title="GLFW">GLFW</a>/<a href="http://glew.sourceforge.net/" title="GLEW">GLEW</a>/<a href="http://glm.g-truc.net/" title="GLM">GLM</a>/<a href="http://www.assimp.org/" title="Assimp">Assimp</a>/<a href="https://bitbucket.org/SpartanJ/soil2" title="SOIL2">SOIL2</a><br>輔助插件: <a href="http://www.horsedrawngames.com/shader-syntax-highlighting-in-visual-studio-2013/" title="Nshader">Nshader for Visual Studio 2015</a></p>
<h4 id="其他事項">其他事項</h4><p><strong> 2016/09/05 前的日誌乃日根據記憶回朔，09/05方開始打算紀錄。 </strong></p>]]>
    
    </summary>
    
      <category term="Development Journal" scheme="http://tokenyet.github.io/tags/Development-Journal/"/>
    
      <category term="OpenGL" scheme="http://tokenyet.github.io/tags/OpenGL/"/>
    
      <category term="開發日誌" scheme="http://tokenyet.github.io/tags/%E9%96%8B%E7%99%BC%E6%97%A5%E8%AA%8C/"/>
    
      <category term="OpenGL" scheme="http://tokenyet.github.io/categories/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenGL之沒有蠢問題 1 - Uniform]]></title>
    <link href="http://tokenyet.github.io/2016/09/04/OpenGL-Questionl-1/"/>
    <id>http://tokenyet.github.io/2016/09/04/OpenGL-Questionl-1/</id>
    <published>2016-09-04T15:10:18.000Z</published>
    <updated>2016-09-05T16:33:41.361Z</updated>
    <content type="html"><![CDATA[<h2 id="閒談">閒談</h2><p>最近在正藉由開發遊戲引擎將以往學過的各種技巧逐步整合起來，像是<strong>Phong</strong>，<strong>Normal Mapping</strong>，<strong>gBuffer</strong>，<strong>Assimp</strong>，<strong>Instancing</strong>，<strong>Parallax Mapping</strong>…等。然後參閱網路上神人的概念，左吸收右吐納總算是有點雛形，但其中遇到最Impress的問題是<code>glGetUniformLocation</code>，就由它來做蠢問題系列的第一集主角吧！</p>
<a id="more"></a>
<h2 id="glGetUniformLocation">glGetUniformLocation</h2><p><code>glGetUniformLocation</code>是碰到Shader即會用到的function，但是Shader爆炸了，卻找不到問題，首先就會面對的也是<code>glGetUniformLocation</code>。</p>
<p>先展示一下Dowen有問題的Shader與Code:</p>
<p>Shader:<br><figure class="highlight cpp"><figcaption><span>shader</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#version 330 core</span></span><br><span class="line"><span class="keyword">struct</span> Material </span><br><span class="line">&#123;</span><br><span class="line">    sampler2D diffuse0;</span><br><span class="line">    sampler2D specular0;</span><br><span class="line">    <span class="keyword">float</span> shininess;</span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Light </span><br><span class="line">&#123;</span><br><span class="line">    vec3 position;</span><br><span class="line">    vec3 ambient;</span><br><span class="line">    vec3 diffuse;</span><br><span class="line">    vec3 specular;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">in vec2 TexCoords;</span><br><span class="line">in vec3 FragPos;</span><br><span class="line">in vec3 Normal;</span><br><span class="line">out vec4 color;</span><br><span class="line"></span><br><span class="line">uniform vec3 viewPos;</span><br><span class="line">uniform Material material;</span><br><span class="line">uniform Light light;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	vec3 lightPos = light.position;</span><br><span class="line">    <span class="comment">// Ambient</span></span><br><span class="line">    vec3 ambient = light.ambient * vec3(texture(material.diffuse0, TexCoords));</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Diffuse</span></span><br><span class="line">	vec3 norm = normalize(Normal);</span><br><span class="line">	vec3 lightDir = normalize(lightPos - FragPos);  </span><br><span class="line">	<span class="keyword">float</span> diff = max(dot(norm, lightDir), <span class="number">0.0</span>);</span><br><span class="line">    vec3 diffuse = light.diffuse * diff * vec3(texture(material.diffuse0, TexCoords));</span><br><span class="line"></span><br><span class="line">	    <span class="comment">// Specular</span></span><br><span class="line">    vec3 viewDir = normalize(viewPos - FragPos);</span><br><span class="line">    vec3 reflectDir = reflect(-lightDir, norm);  </span><br><span class="line">    <span class="keyword">float</span> spec = <span class="built_in">pow</span>(max(dot(viewDir, reflectDir), <span class="number">0.0</span>), material.shininess);</span><br><span class="line">    vec3 specular = light.specular * spec * vec3(texture(material.specular0, TexCoords));</span><br><span class="line">    <span class="comment">//color = vec4(1.0f, 0.5f, 0.2f, 1.0f);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//color = vec4(ambient + diffuse + specular, 1.0f);  </span></span><br><span class="line">	color = vec4(specular, <span class="number">1.0f</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>CPP原始碼的部分:<br><figure class="highlight cpp"><figcaption><span>code</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> StaticShader::SetDiffuseTexture(GLuint texture)</span><br><span class="line">&#123;</span><br><span class="line">	glActiveTexture(GL_TEXTURE0 + diffuseCount);</span><br><span class="line">	glBindTexture(GL_TEXTURE_2D, texture);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> diffuse = <span class="string">"material.diffuse"</span> + <span class="built_in">std</span>::to_string(diffuseCount);</span><br><span class="line">	<span class="keyword">int</span> loc = GetUniformLocation(diffuse.c_str());</span><br><span class="line">	<span class="keyword">if</span> (loc == -<span class="number">1</span>) Debug::Log(<span class="string">"Diffuse texture Setting Fail."</span>);</span><br><span class="line">	glUniform1i(loc, diffuseCount);</span><br><span class="line">	diffuseCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>好了，看起來完美地有做debug處理，所以自製的Debug在Visual Studio下方的輸出視窗中印出了這樣的訊息。</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Diffuse texture <span class="keyword">Setting</span> <span class="keyword">Fail</span>.</span><br><span class="line">Light Ambient <span class="keyword">Setting</span> <span class="keyword">Fail</span>.</span><br><span class="line">Light Diffuse <span class="keyword">Setting</span> <span class="keyword">Fail</span>.</span><br></pre></td></tr></table></figure>
<p>原因是<code>glGetUniformLocation</code>回傳$-1$，意思是找不到該Uniform位置。然後我Double Check，Triple Check，….Check，複製貼上確保命名問題正確等手法，還是出現同樣地訊息。</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Diffuse texture <span class="keyword">Setting</span> <span class="keyword">Fail</span>.</span><br><span class="line">Light Ambient <span class="keyword">Setting</span> <span class="keyword">Fail</span>.</span><br><span class="line">Light Diffuse <span class="keyword">Setting</span> <span class="keyword">Fail</span>.</span><br></pre></td></tr></table></figure>
<p>之後想找更深入的Debug方法，於是就找上了列出所有Attribute與Uniform的偵錯技巧，<a href="http://stackoverflow.com/questions/440144/in-opengl-is-there-a-way-to-get-a-list-of-all-uniforms-attribs-used-by-a-shade" title="get all uniform and attributes" target="_blank" rel="external">原文</a>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">ListAttributes</span><span class="params">()</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">	GLint i;</span><br><span class="line">	GLint count;</span><br><span class="line"></span><br><span class="line">	GLint size; <span class="comment">// size of the variable</span></span><br><span class="line">	GLenum type; <span class="comment">// type of the variable (float, vec3 or mat4, etc)</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> GLsizei bufSize = <span class="number">16</span>; <span class="comment">// maximum name length</span></span><br><span class="line">	GLchar name[bufSize]; <span class="comment">// variable name in GLSL</span></span><br><span class="line">	GLsizei length; <span class="comment">// name length</span></span><br><span class="line"></span><br><span class="line">	glGetProgramiv(program, GL_ACTIVE_ATTRIBUTES, &amp;count);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Active Attributes: %d\n"</span>, count);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">	&#123;</span><br><span class="line">	glGetActiveAttrib(program, (GLuint)i, bufSize, &amp;length, &amp;size, &amp;type, name);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Attribute #%d Type: %u Name: %s\n"</span>, i, type, name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>列出來的訊息如下:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Active <span class="string">Attributes:</span> <span class="number">3</span></span><br><span class="line">Attribute #<span class="number">0</span> <span class="string">Type :</span><span class="number">35665</span><span class="string">Name :</span> normal</span><br><span class="line">Attribute #<span class="number">1</span> <span class="string">Type :</span><span class="number">35665</span><span class="string">Name :</span> position</span><br><span class="line">Attribute #<span class="number">2</span> <span class="string">Type :</span><span class="number">35664</span><span class="string">Name :</span> texCoord</span><br><span class="line">Active <span class="string">Uniforms:</span> <span class="number">8</span></span><br><span class="line">Uniform #<span class="number">0</span> <span class="string">Type :</span><span class="number">35665</span><span class="string">Name :</span> light.position</span><br><span class="line">Uniform #<span class="number">1</span> <span class="string">Type :</span><span class="number">35665</span><span class="string">Name :</span> light.specular</span><br><span class="line">Uniform #<span class="number">2</span> <span class="string">Type :</span><span class="number">5126</span><span class="string">Name :</span> material.shinin</span><br><span class="line">Uniform #<span class="number">3</span> <span class="string">Type :</span><span class="number">35678</span><span class="string">Name :</span> material.specul</span><br><span class="line">Uniform #<span class="number">4</span> <span class="string">Type :</span><span class="number">35676</span><span class="string">Name :</span> model</span><br><span class="line">Uniform #<span class="number">5</span> <span class="string">Type :</span><span class="number">35676</span><span class="string">Name :</span> projection</span><br><span class="line">Uniform #<span class="number">6</span> <span class="string">Type :</span><span class="number">35676</span><span class="string">Name :</span> view</span><br><span class="line">Uniform #<span class="number">7</span> <span class="string">Type :</span><span class="number">35665</span><span class="string">Name :</span> viewPos</span><br></pre></td></tr></table></figure>
<p>果然少了<strong>原本</strong>應該要出現的那幾項，因此Dowen就開始反覆的重建專案，清除，重建，重開整個project，想說這招也許能成功，一個非常祈禱式的Debug(?)。</p>
<p>最後終於找到了一篇理念型文章，告知了我一些重要的概念，<a href="http://stackoverflow.com/questions/20751157/glsl-vertex-shader-glgetuniformlocation-fails" title="glGetUniformLocation fails" target="_blank" rel="external">原文</a>在此，整篇的大致概念是這樣的。<code>glGetUniformLocation</code>是一個取得<strong>Active Uniform</strong>，<strong>Active Uniform</strong>，<strong>Active Uniform</strong>的一個function。又什麼是<strong>Active Uniform</strong>呢? 假設手上有Vertex Shader跟Fragment Shader，將兩者合為一個Program之後，OpenGL會非常貼心地，幫我們把那些不會被用到的變數給移除，就如之前貼的Shader來講好了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vec3 viewDir = normalize(viewPos - FragPos);</span><br><span class="line">vec3 reflectDir = reflect(-lightDir, norm);  </span><br><span class="line"><span class="keyword">float</span> spec = <span class="built_in">pow</span>(max(dot(viewDir, reflectDir), <span class="number">0.0</span>), material.shininess);</span><br><span class="line">vec3 specular = light.specular * spec * vec3(texture(material.specular0, TexCoords));</span><br><span class="line"></span><br><span class="line"><span class="comment">//color = vec4(ambient + diffuse + specular, 1.0f);  </span></span><br><span class="line">color = vec4(specular, <span class="number">1.0f</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Diffuse texture <span class="keyword">Setting</span> <span class="keyword">Fail</span>.</span><br><span class="line">Light Ambient <span class="keyword">Setting</span> <span class="keyword">Fail</span>.</span><br><span class="line">Light Diffuse <span class="keyword">Setting</span> <span class="keyword">Fail</span>.</span><br></pre></td></tr></table></figure>
<p>由於輸出的<code>color</code>是藉由<code>specular</code>的值，然後<code>specular</code>是源自於<code>material.specular0</code>，跟<code>material.diffuse0</code>完全無關，所以<code>diffuse0</code>就被從Shader Code中移除，而<code>light.ambient</code>跟<code>light.diffuse</code>也是同<code>material.diffuse0</code>一樣，被斷定為無用之人，因此被踢出了菁因工會，哦不是，我是說Shader Program。</p>
<p>在理解到這個精粹(?)後，Dowen將註解解開(本來是想單獨檢視<code>specular</code>所以才這樣註解)，然後將目前的輸出註解掉。天堂的門就打開了！</p>
<img src="/images/OQ1/complete.png" width="420">
<h2 id="小結">小結</h2><p>希望對剛使用OpenGL，然後Debug一整天的人有幫助，像Dowen解了有五小時之多啊！</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="閒談">閒談</h2><p>最近在正藉由開發遊戲引擎將以往學過的各種技巧逐步整合起來，像是<strong>Phong</strong>，<strong>Normal Mapping</strong>，<strong>gBuffer</strong>，<strong>Assimp</strong>，<strong>Instancing</strong>，<strong>Parallax Mapping</strong>…等。然後參閱網路上神人的概念，左吸收右吐納總算是有點雛形，但其中遇到最Impress的問題是<code>glGetUniformLocation</code>，就由它來做蠢問題系列的第一集主角吧！</p>]]>
    
    </summary>
    
      <category term="OpenGL問題" scheme="http://tokenyet.github.io/tags/OpenGL%E5%95%8F%E9%A1%8C/"/>
    
      <category term="glGetUniformLocation" scheme="http://tokenyet.github.io/tags/glGetUniformLocation/"/>
    
      <category term="glGetUniformLocation bug" scheme="http://tokenyet.github.io/tags/glGetUniformLocation-bug/"/>
    
      <category term="glGetUniformLocation fails" scheme="http://tokenyet.github.io/tags/glGetUniformLocation-fails/"/>
    
      <category term="glGetUniformLocation 問題" scheme="http://tokenyet.github.io/tags/glGetUniformLocation-%E5%95%8F%E9%A1%8C/"/>
    
      <category term="OpenGL" scheme="http://tokenyet.github.io/categories/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenGL 藍寶入門教學 5: 資料型態]]></title>
    <link href="http://tokenyet.github.io/2016/08/25/OpenGL-Beginner-Tutorial-5-Data/"/>
    <id>http://tokenyet.github.io/2016/08/25/OpenGL-Beginner-Tutorial-5-Data/</id>
    <published>2016-08-25T08:30:29.000Z</published>
    <updated>2016-08-25T14:04:52.298Z</updated>
    <content type="html"><![CDATA[<h2 id="開始前介紹">開始前介紹</h2><p>本篇將會大略的提及OpenGL中Buffer,Unifrom還有一點點Shader Storage Block的部分，而關於Atomic或同步問題，就先略過。如果對Shader中GPU與CPU不熟，可能會對本篇閱讀有礙。畢竟藍寶書竟然將Shader的部分放在後頭，Shader連結部分都還不熟，就先切入細節Buffer,Uniform的部分。</p>
<a id="more"></a>
<h2 id="Buffer">Buffer</h2><p>對於Buffer的使用第三篇與第二篇，足夠初學者使用，因此這部分將章節所使用到的Buffer函式列出來逐步講解。</p>
<ul>
<li><code>glCreateBuffers(GLsizei n, GLuint* buffer)</code> : 與OpenGL要buffer的編號，與glGenBuffers功能相同。</li>
<li><code>glBindBuffer(GLenum target, GLuint buffer)</code> : 將某編號buffer綁訂在要求的target容器上。</li>
<li><code>glBufferStorage(GLenum target, GLsizeiptr size, const void* data, GLbitfield flags)</code> : 將指定容器的空間與資料填入,並告訴OpenGL後續用途，這樣才會配置最佳存取空間。</li>
<li><code>glNameBufferStorage(GLuint buffer, GLsizeiptr size, const void* data, GLbitfield flags)</code> : 與 <code>glBufferStorage</code>相同，只是指定的是buffer編號。</li>
<li><code>glBufferSubData(GLenum target, GLintptr offset, GLsizeptr size, const GLvoid* data)</code> : 根據offset與size的定義，將資料放在指定記憶體位置處。</li>
<li><code>glNameBufferSubData(GLuint buffer, GLintptr offset, GLsizeptr size, const GLvoid* data)</code> : 同<code>glBufferSubData</code>。</li>
<li><code>glMapBuffer(GLenum target, GLenum usage)</code> : 從指定容器取出Pointer，可直接進行記憶體配置，不須像<code>glBufferStorage</code>或<code>glBufferData</code>需要多一個copy。</li>
<li><code>glMapNamedBuffer(GLuint buffer, GLenum usage)</code> : 同<code>glMapBuffer(GLenum target, GLenum usage)</code>。</li>
<li><code>glMapBufferRange(GLenum target, GLintptr offset, GLsizeiptr length, GLenum usage)</code> : 指定要修改的記憶體區域，回傳Pointer可直接進行記憶體配置 。</li>
<li><code>glMapNamedBufferRange(GLuint buffer, GLintptr offset, GLsizeiptr length, GLenum usage)</code> : 同<code>glMapBufferRange</code>。</li>
<li><code>glClearBufferSubData(GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void* data)</code> : 用來清除buffer特定區域的值，然後可用data取代。</li>
<li><code>glClearNamedBufferSubData(GLuint buffer, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void* data)</code> : 同<code>glClearBufferSubData</code>。</li>
<li><code>glCopyBufferSubData(GLenum readtarget, GLenum writetarget, GLintptr readoffset, GLintptr writeoffset, GLsizeiptr size)</code> : 將Buffer資料複製到指定Buffer中。</li>
<li><code>glCopyNamedBufferSubData(GLenum readtarget, GLenum writetarget, GLintptr readoffset, GLintptr writeoffset, GLsizeiptr size)</code> : 同<code>glCopyBufferSubData</code>。</li>
<li><code>glVertexArrayAttribBinding(GLuint vaobj, GLuint attribindex, GLuint bindingindex)</code> : 從binding區域中取出buffer，之後對應到vao使用的shader中的位置。</li>
<li><code>glVertexArrayVertexBuffer(GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride)</code> : 將buffer的指定記憶體區域綁定到binding區域。</li>
</ul>
<blockquote><h4 id="Binding區域">Binding區域</h4><p>Binding區域是一個OpenGL定義的一個待綁區，可以想像成一串陣列，可根據指定vbo buffer或是簡稱buffer，將有資料的buffer放到指定綁定索引後，不同的vao即可以方便使用同個buffer。</p>
</blockquote>
<ul>
<li><code>glVertexArrayAttribFormat(GLuint vaobj, GLuint attribindex, GLuint size, GLenum type, GLboolean normalized, GLuint relativeoffset)</code> : 定義第幾個location讀取buffer資料時，要以什麼方式進行讀取，如同第三篇所用到的<code>glVertexAttribPointer</code>。</li>
<li><code>glEnableVertexArrayAttrib(GLuint vao, GLuint index )</code> : 啟動第幾個位置，不啟動Vertex Shader無法接收。</li>
<li><code>glDisableVertexArrayAttrib(GLuint vao, GLuint index )</code> : 關閉VS的接收。</li>
</ul>
<h2 id="Uniforms">Uniforms</h2><p>Unifrom與VertexAttribute的差別對初學者來說應該差異不大，因為都能夠傳送資料進入Shader。不過這裡可以先給一個概念，VertexAttribute強調的是Vertex，也就是根據每個頂點，而有所變動。而Unifrom的中文意思是制式，不變的，利用Unifrom通常只會在一個繪製才能變動一次值，畢竟跑Shader的時候，Uniform的值已經進入GPU。</p>
<p>而Unifrom有兩種形式，一種稱為<strong>Default Block Uniforms</strong>，另一種稱為<strong> Uniform Block</strong>。</p>
<h3 id="Default_Block_Unifroms">Default Block Unifroms</h3><p>Uniform的使用，最傳統的方式如下:</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="keyword">float</span> time;</span><br><span class="line"><span class="keyword">uniform</span> <span class="keyword">int</span> selection;</span><br><span class="line"><span class="keyword">uniform</span> <span class="keyword">vec4</span> backgroundColor;</span><br><span class="line"><span class="keyword">uniform</span> <span class="keyword">mat4</span> mvp;</span><br></pre></td></tr></table></figure>
<p>而進階一點可以定義每個uniform的位置，如果沒定義，如上方的形式，就會預設自動配一個，因此通常沒必要定義。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">layout</span> (location = <span class="number">87</span>) <span class="keyword">uniform</span> <span class="keyword">vec4</span> specificStuff;</span><br></pre></td></tr></table></figure>
<p>而如果沒有定義location的一般用法，要傳值的話需要使用<code>glGetUnifromLocation(program, name)</code>，傳入編譯好的program與想要傳值的變數名稱，就可以取得其location。</p>
<h4 id="實際情形模擬">實際情形模擬</h4><p>假設實際位置如下:</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">layout</span> (location = <span class="number">0</span>) <span class="keyword">uniform</span> <span class="keyword">float</span> time;</span><br><span class="line"><span class="keyword">layout</span> (location = <span class="number">1</span>) <span class="keyword">uniform</span> <span class="keyword">int</span> selection;</span><br><span class="line"><span class="keyword">layout</span> (location = <span class="number">2</span>) <span class="keyword">uniform</span> <span class="keyword">vec4</span> backgroundColor;</span><br><span class="line"><span class="keyword">layout</span> (location = <span class="number">3</span>) <span class="keyword">uniform</span> <span class="keyword">mat4</span> mvp;</span><br></pre></td></tr></table></figure>
<p>那麼再傳值的時候就要用適當的<code>glUnifromXY</code>，X代表數字Y代表型態，如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">glUseProgram(program);</span><br><span class="line">glUniform1f(<span class="number">0</span>, (GLfloat)systemTime);</span><br><span class="line">glUniform1i(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">glUniform4f(<span class="number">2</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">glUniformMatrix4fv(<span class="number">3</span>, <span class="number">1</span>, GL_FALSE, glm::value_ptr(mvp));</span><br></pre></td></tr></table></figure>
<h3 id="Uniform_Blocks">Uniform Blocks</h3><p>有時候不同Shader會傳入相同的值(如光影中幾乎需要攝影機的位置)，這時候Uniform Block就派上用場了，在OpenGL程式中，定義一個<strong>Uniform Buffer Object</strong>，然後傳入每個需要用到此Uniform的Shader中，直接從記憶體傳入GPU就可以免去每個Shader程式都需要用<code>glUniform</code>來傳遞。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">layout</span> (location = <span class="number">0</span>) <span class="keyword">in</span> <span class="keyword">vec4</span> position;</span><br><span class="line"><span class="keyword">layout</span>(std140) <span class="keyword">uniform</span> CommonParameter</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> invisible;</span><br><span class="line">	<span class="keyword">float</span> time;</span><br><span class="line">	<span class="keyword">float</span> strange[<span class="number">3</span>];</span><br><span class="line">	<span class="keyword">vec3</span> camera;</span><br><span class="line">	<span class="keyword">mat4</span> mvp;</span><br><span class="line">	<span class="keyword">int</span> another;</span><br><span class="line">&#125; common;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">	... <span class="comment">// some shader code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面就是Unifrom Block最常用的方式，而<code>std140</code>代表的是標準格式，代表每個型態的格式大小規範。而定義的模式是，一筆資料的邊界必須是16 bytes對齊，float代表16 bytes，vec1~2代表8 bytes, vec3~4代表16 bytes，mat則是4個16byte。概念如下:</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">layout</span>(std140) <span class="keyword">uniform</span> CommonParameter</span><br><span class="line">&#123;</span><br><span class="line">                          <span class="comment">//base_aligment-aligment_offset</span></span><br><span class="line">	<span class="keyword">int</span> invisible;        <span class="comment">//  4-0</span></span><br><span class="line">	<span class="keyword">float</span> time;           <span class="comment">// 16-16</span></span><br><span class="line">	<span class="keyword">float</span> strange[<span class="number">3</span>];     <span class="comment">// 16-32</span></span><br><span class="line">	                      <span class="comment">// 16-48</span></span><br><span class="line">	                      <span class="comment">// 16-64</span></span><br><span class="line">	<span class="keyword">vec3</span> camera;          <span class="comment">// 16-80</span></span><br><span class="line">	<span class="keyword">mat4</span> mvp;             <span class="comment">// 16-96</span></span><br><span class="line">	                      <span class="comment">// 16-112</span></span><br><span class="line">	                      <span class="comment">// 16-128</span></span><br><span class="line">	                      <span class="comment">// 16-144</span></span><br><span class="line">	<span class="keyword">int</span> another;          <span class="comment">//  4-160</span></span><br><span class="line">&#125; common;</span><br></pre></td></tr></table></figure>
<h4 id="初始化UBO">初始化UBO</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GLuint ubo;</span><br><span class="line">glGenBuffers(<span class="number">1</span>, &amp;ubo);</span><br><span class="line">glBindBuffer(GL_UNIFORM_BUFFER, ubo);</span><br><span class="line">glBufferData(GL_UNIFORM_BUFFER, <span class="number">160</span>, NULL, GL_STATIC_DRAW);</span><br><span class="line">glBindBuffer(GL_UNIFORM_BUFFER, <span class="number">0</span>);</span><br><span class="line">glBindBufferBase(GL_UNIFORM_BUFFER, <span class="number">0</span>, ubo); <span class="comment">// binding point to 0</span></span><br></pre></td></tr></table></figure>
<h4 id="填入內容">填入內容</h4><p>通常會在loop的階段使用，除非永遠是Const，那<code>glBufferSubData</code>就可以在迴圈外使用。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">GLuint invisible = getInvis();</span><br><span class="line">GLfloat time = geTime();</span><br><span class="line">glm::mat4 mvp = getMvp();</span><br><span class="line">GLfloat strange[<span class="number">3</span>] = getSomeStrange();</span><br><span class="line">glm::vec3 cameraPos = getCamPos();</span><br><span class="line">GLuint another = getValue();</span><br><span class="line">glBindBuffer(GL_UNIFORM_BUFFER, ubo);</span><br><span class="line"><span class="keyword">int</span> offset = <span class="number">0</span>;</span><br><span class="line">glBufferSubData(GL_UNIFORM_BUFFER, offset, <span class="keyword">sizeof</span>(GLuint), glm::value_ptr(invisible));</span><br><span class="line">offset += <span class="keyword">sizeof</span>(GLuint);</span><br><span class="line">glBufferSubData(GL_UNIFORM_BUFFER, offset, <span class="keyword">sizeof</span>(GLfloat), glm::value_ptr(time));</span><br><span class="line">offset += <span class="keyword">sizeof</span>(GLfloat);</span><br><span class="line">glBufferSubData(GL_UNIFORM_BUFFER, offset, <span class="number">3</span> * <span class="keyword">sizeof</span>(GLfloat), glm::value_ptr(strange));</span><br><span class="line">offset += <span class="number">3</span> * <span class="keyword">sizeof</span>(GLfloat);</span><br><span class="line">glBufferSubData(GL_UNIFORM_BUFFER, offset, <span class="keyword">sizeof</span>(glm::vec3), glm::value_ptr(cameraPos));</span><br><span class="line">offset += <span class="keyword">sizeof</span>(glm::vec3);</span><br><span class="line">glBufferSubData(GL_UNIFORM_BUFFER, offset, <span class="keyword">sizeof</span>(glm::mat4), glm::value_ptr(mvp));</span><br><span class="line">offset += <span class="keyword">sizeof</span>(glm::mat4);</span><br><span class="line">glBufferSubData(GL_UNIFORM_BUFFER, offset, <span class="keyword">sizeof</span>(GLuint), glm::value_ptr(another));</span><br><span class="line">glBindBuffer(GL_UNIFORM_BUFFER, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<h4 id="Shader綁定UBO">Shader綁定UBO</h4><p>這段不用再迴圈內，事先定義好要取得的BindingPoint，Buffer不管怎麼變，Shader都取的到。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GLuint shaderUsedUBO1 = glGetUnifromBlockLocationIndex(program1, <span class="string">"CommonParameter"</span>);</span><br><span class="line">GLuint shaderUsedUBO2 = glGetUnifromBlockLocationIndex(program2, <span class="string">"CommonParameter"</span>);</span><br><span class="line">GLuint shaderUsedUBO2 = glGetUnifromBlockLocationIndex(program3, <span class="string">"CommonParameter"</span>);</span><br><span class="line"></span><br><span class="line">glGetUnifromBlockBinding(program1, shaderUsedUBO1, <span class="number">0</span>);</span><br><span class="line">glGetUnifromBlockBinding(program2, shaderUsedUBO2, <span class="number">0</span>);</span><br><span class="line">glGetUnifromBlockBinding(program3, shaderUsedUBO3, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h2 id="Shader_Storage_Block">Shader Storage Block</h2><p>與UBO很相似，但不同的地方在於這裡可以讓Shader進行修改裡面的內容，而且這會影響到OpenGL程式端的Buffer內容。定義如下:</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">layout</span> (binding=<span class="number">0</span>, std430) buffer stblock</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">vec4</span> data;</span><br><span class="line">    <span class="keyword">int</span> test;</span><br><span class="line">    <span class="keyword">vec3</span> color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要是把uniform改為buffer，而這裡的<code>std430</code>代表一個更嚴格的格式，在此不多做說明，用<code>std140</code>即可。</p>
<h2 id="其他">其他</h2><p>Shader Storage Block還有一個Atomic的應用，主要關於平行處理中的一些細節問題。還有一個特別的Atomic Counter是一些進階技巧，Dowen也未曾碰過。</p>
<h2 id="小結">小結</h2><p>在書中的第五章剩餘還有Texture的部分，是有關於材質貼圖的部分，算是一個極為重要的一Part，但是需要介紹到一個新的圖片載入函式庫，可能會使篇幅變得如同第四篇一樣巨大，因此本篇就先到此結尾。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="開始前介紹">開始前介紹</h2><p>本篇將會大略的提及OpenGL中Buffer,Unifrom還有一點點Shader Storage Block的部分，而關於Atomic或同步問題，就先略過。如果對Shader中GPU與CPU不熟，可能會對本篇閱讀有礙。畢竟藍寶書竟然將Shader的部分放在後頭，Shader連結部分都還不熟，就先切入細節Buffer,Uniform的部分。</p>]]>
    
    </summary>
    
      <category term="OpenGL" scheme="http://tokenyet.github.io/tags/OpenGL/"/>
    
      <category term="OpenGL Extension" scheme="http://tokenyet.github.io/tags/OpenGL-Extension/"/>
    
      <category term="OpenGL Tutorial" scheme="http://tokenyet.github.io/tags/OpenGL-Tutorial/"/>
    
      <category term="OpenGL intro" scheme="http://tokenyet.github.io/tags/OpenGL-intro/"/>
    
      <category term="OpenGL入門教學" scheme="http://tokenyet.github.io/tags/OpenGL%E5%85%A5%E9%96%80%E6%95%99%E5%AD%B8/"/>
    
      <category term="OpenGL教學" scheme="http://tokenyet.github.io/tags/OpenGL%E6%95%99%E5%AD%B8/"/>
    
      <category term="OpenGL" scheme="http://tokenyet.github.io/categories/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenGL 關於藍寶入門教學]]></title>
    <link href="http://tokenyet.github.io/2016/08/25/OpenGL-Beginner-Tutorial-EX-Read/"/>
    <id>http://tokenyet.github.io/2016/08/25/OpenGL-Beginner-Tutorial-EX-Read/</id>
    <published>2016-08-25T07:30:29.000Z</published>
    <updated>2016-08-25T14:07:36.029Z</updated>
    <content type="html"><![CDATA[<h2 id="關於本篇說明">關於本篇說明</h2><p>藍寶書本來認為是一本<strong>適合入門</strong>者的書，但是漸漸的發現，完全跟入門無緣。因此標題從「OpenGL 入門教學」更改為「OpenGL 藍寶入門教學」，跟著藍寶書走馬看花，真的<strong>想用藍寶書學習者可以跟著教學走</strong>。打個遊戲的比方來說，如果說學習OpenGL有分為簡單、普通、困難、極難來講，Dowen認為<strong>本書屬於困難到極難</strong>的等級，而自己是普通的一周目玩家，要通關這本書，可能要技巧性的完成，比方說將一些艱深，身為初學者根本用不到且體會不到的部分先略過，僅提及而不深究。</p>
<p>自己照著藍寶的教學，隨興才會寫，目前Dowen打算先自己看完，教學先擱置，如果有讀者需要幫助可以留言詢問，或許會促進我發文的動力。終於體會到論壇中，「你的回覆是我發文的最大動力」這句話了XD</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="關於本篇說明">關於本篇說明</h2><p>藍寶書本來認為是一本<strong>適合入門</strong>者的書，但是漸漸的發現，完全跟入門無緣。因此標題從「OpenGL 入門教學」更改為「OpenGL 藍寶入門教學」，跟著藍寶書走馬看花，真的<strong>想用]]>
    </summary>
    
      <category term="OpenGL入門教學" scheme="http://tokenyet.github.io/tags/OpenGL%E5%85%A5%E9%96%80%E6%95%99%E5%AD%B8/"/>
    
      <category term="藍寶書" scheme="http://tokenyet.github.io/tags/%E8%97%8D%E5%AF%B6%E6%9B%B8/"/>
    
      <category term="OpenGL" scheme="http://tokenyet.github.io/categories/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenGL 藍寶入門教學 4: 數學]]></title>
    <link href="http://tokenyet.github.io/2016/08/11/OpenGL-Beginner-Tutorial-4-Math/"/>
    <id>http://tokenyet.github.io/2016/08/11/OpenGL-Beginner-Tutorial-4-Math/</id>
    <published>2016-08-11T08:44:20.000Z</published>
    <updated>2016-09-05T16:31:16.231Z</updated>
    <content type="html"><![CDATA[<h2 id="開始前介紹">開始前介紹</h2><p>這一章節主要是介紹一些數學的基礎，如果發現哪個部分不熟的話，最好能親自磨練一下，因為以後常常需要的時候，如果不懂箇中原理，那麼在偵錯或是實作上，會遇到一些麻煩。當然領悟過後能寫起來是最推薦的方式，以後忘了的時候瞟一眼就行了。初學者如果看不懂本篇的話，可以暫且跳過無妨，當有用到再回頭看，因為現在的文章是搭配官方藍寶書的章節推進，而藍寶書比較適合中階以上閱讀者，所以本篇對初學者來說應該很吃力。<br>接下來會介紹的內容基本上有:</p>
<ul>
<li>向量</li>
<li>反射與折射</li>
<li>矩陣</li>
<li>相關座標系統</li>
<li>攝影機</li>
<li>透視投影與正交投影</li>
<li>直線與曲線</li>
<li>GLM</li>
</ul>
<a id="more"></a>
<h2 id="向量">向量</h2><p>這邊應該大家都有學過，在此只是把我自己領略的概念描述出來，如果不懂的話，請參閱其他數學專業網站。</p>
<h3 id="何謂向量">何謂向量</h3><p>向量的定義是一個方向附帶著一個量的數值，而為什麼需要一個有數值的方向呢？因為想將向量運用到各種不同的地方，這樣就可以不需要同樣的原點與終點來重現這樣的動作。我們假設一個二維的座標平面，上面有一個點 $p_1$ 還有一個點 $p_2$ ，用 $ p_2 - p_1 $  所得到的就是從 $ p_1 $ 指向 $ p_2 $ 的向量，如果想不通就想成 $p_2$ 與原點 $ o $ 的關係是 $ p_2 - o $，也就是從原點指向 $ p_2 $ 的向量。</p>
<h3 id="基本性質">基本性質</h3><p>向量的加減性質跳過。</p>
<h3 id="長度">長度</h3><p>如果向量是 $ (1,2,3) $ 長度的定義是 $ \sqrt{1^2 + 2^2 + 3^2} $，向量已經是兩點相減的結果，所以只要將各個分量平方後開根號就是長度。</p>
<h3 id="單位向量">單位向量</h3><p>若向量是 $ (1,2,3) $ 則單位向量就是其向量除以長度，也就是 $ \left(\frac{1}{\sqrt{14}},\frac{2}{\sqrt{14}},\frac{3}{\sqrt{14}}\right) $<br>這樣的好處是，可以得到往該方向一個單位長度需要多少向量。也就是說上方的各自平方後相加長度等於一。而單位向量的概念在OpenGL中稱之為<strong>Normalize</strong>。</p>
<h3 id="內積">內積</h3><p>內積的定義是這樣的 $ \vec{a} \cdot \vec{b} = a_xb_x+a_yb_y+a_zb_z $<br>直接看看不出它的意義是什麼，他還有另一個特性是 $ \vec{a} \cdot \vec{b} =  \left| \vec{a} \right| \left| \vec{b} \right| \cos{\theta} $<br>在圖學中內積常常用來求的是角度，也就是說根據上方的另一個性質，將長度移到左方然後算出內積的值，就可以得到 $ value = \cos{\theta} $ 的情況，也就是可以知道角度是多少，這是內積常常運用在圖學中的部分。至於上方的兩定義由來就不探討。</p>
<h3 id="外積">外積</h3><p>外積的定義是 $ \vec{V}_1 \times \vec{V}_2  = \vec{V}_3$<br><span>$$\begin{bmatrix} 
V_3.x \\
V_3.y \\
V_3.z \\
\end{bmatrix}
= 
\begin{bmatrix} 
V_1.y \cdot V_2.z - V_1.z \cdot V_2.y \\
V_1.z \cdot V_2.x - V_1.x \cdot V_2.z \\ 
V_1.x \cdot V_2.y - V_1.y \cdot V_2.x \\
\end{bmatrix}$$</span><!-- Has MathJax --><br>得到的 $ \vec{V}_3 $ 就是垂直於  $ \vec{V}_1 , \vec{V}_2 $的向量，依照<a href="https://zh.wikipedia.org/wiki/右手定則" target="_blank" rel="external">弗萊明右手定則</a>就可以知道該垂直向量應該往哪裡垂直，且別擔心，不管怎麼比都會在定則內的。在圖學中，會用到的就是外積算出來垂直於表面的特性，也就是Normal Vector，這個光影特效中時常使用的向量。</p>
<h2 id="反射與折射">反射與折射</h2><h3 id="反射">反射</h3><p>反射有個特性，就是入射角等於反射角，然後依照圖片所示，我們要算出反射角的方法有兩種。一種是不用將入射角反轉，直接位移兩個垂直平面的分量。另一種是將入射角反轉，移動兩個水平分量，而這裡介紹的是移動兩個垂直分量的方法。<br>結果公式為:<br><span>$R_{reflect} = R_{in} - (2N \cdot R_{in} )N$</span><!-- Has MathJax --><br>解釋 : 反射分量 = 入射分量 - 兩個垂直表面的分量。</p>
<p>正式理解，我們直觀來看入射角 <span>$R_{in}$</span><!-- Has MathJax --> 應該要減去兩個垂直於法向量 <span>$N$</span><!-- Has MathJax --> 的 <span>$R_{in}$</span><!-- Has MathJax --> 垂直分量。直觀來看就是 <span>$R_{in}$</span><!-- Has MathJax --> 加上兩個 <span>$\left| -R_{in} \right| \cos{\theta} \times \frac{N}{\left|N\right|}$</span><!-- Has MathJax -->，而 <span>$-R_{in}$</span><!-- Has MathJax --> 代表反的入射角，因為要跟垂直分量算夾角，必須要兩向量都從頭個原點出發才行。那為何是 <span>$\left| -R_{in} \right|$</span><!-- Has MathJax --> 呢?因為透過三角形的畢氏定理，就可以換算成在該垂直分量上的長度多少，之後再轉回向量，也就是要乘上 <span>$N$</span><!-- Has MathJax --> 的單位向量 <span>$\frac{N}{\left|N\right|}$</span><!-- Has MathJax -->，就可以得知在該方向上的分量是多少，這裡運用到投影向量的技巧，需要自行去熟悉一下。</p>
<p>來認真的推看看:<br>原式:<br><span>$R_{in} + 2 \times \left| -R_{in} \right| \cos{\theta} \times \frac{N}{\left|N\right|}$</span><!-- Has MathJax --></p>
<p>化簡多餘的部分(對了N固定是單位向量，也就是長度為1):<br><span>$R_{in} + 2 \times \left| -R_{in} \right| \cos{\theta} \times N$</span><!-- Has MathJax --></p>
<p>由於 <span>$-R_{in} \cdot N = \left| -R_{in} \right| \left| N \right|  \cos{\theta}$</span><!-- Has MathJax --></p>
<p>又可以是 <span>$-R_{in} \cdot N = \left| -R_{in} \right| \cos{\theta}$</span><!-- Has MathJax --></p>
<p>因此化簡為:<br><span>$R_{in} + 2 \times -R_{in} \cdot N * N$</span><!-- Has MathJax --></p>
<p>負號提出來:<br><span>$R_{in} - 2 \times R_{in} \cdot N * N$</span><!-- Has MathJax --></p>
<p>最後將上方的原式拿來比較:<br><span>$R_{reflect} = R_{in} - (2N \cdot R_{in} )N = R_{in} - 2 \times R_{in} \cdot N \times N$</span><!-- Has MathJax --></p>
<p>得證相等，與理解的無誤。</p>
<h3 id="折射">折射</h3><p>折射的部分，Dowen也尚未理解，公式牽涉較深物理，理論是說，入射方介質 $ \eta $  小於折射方介質$ \eta $ ，那折射方就會偏向法向量，反之就會偏離，不是物理學者，我想知道概念足矣。<br><span>$$\begin{gather}
k = 1 - \eta^2(1 - (N \cdot R)^2) \\
R_{refract} = 
\begin{cases} 
0.0 &amp; \text{if $k &lt; 0.0 $} \\[2ex]
\eta R - (\eta (N \cdot R) + \sqrt{k})N &amp; \text{if $k \ge 0.0$}
\end{cases}
\end{gather}$$</span><!-- Has MathJax --></p>
<h2 id="矩陣">矩陣</h2><p>說到矩陣，以前完全想不透為何經過矩陣轉換，得到的東西是一個有意義的東西。某日深研後，發現矩陣是由方程式的演變而來的，聽起來很理所當然，不過當題目做多了，反思一下卻忘了本源是什麼，就有點慌慌的。接下來就用方程式與矩陣一起說明，不直接用矩陣說明的方式來教學。至於矩陣的乘法，在這裡就不贅述，矩陣只是一種方程式變相的工具使用而已，如果有疑慮請詳閱專業數學相關網站。</p>
<h3 id="位移">位移</h3><p>假設一物體位於三維空間中 <span>$p_{old} (x, y, z)$</span><!-- Has MathJax --> 點上，那要移動至 <span>$p_{new} (x + 2 ,y + 3 ,z-5)$</span><!-- Has MathJax --> 的點在方程式上該如何表示呢?<br><span>$$p_{old} (x_{old}, y_{old}, z_{old}) , \\
p_{new} (x_{new}, y_{new}, z_{new}) , \\
x_{new} = x_{old} + 2 \\
y_{new} = y_{old} + 3 \\
z_{new} = z_{old} - 5$$</span><!-- Has MathJax --><br>位移在方程式上算是比較特殊的轉法，一般我們矩陣是3x1(新座標) = 3x3 * 3x1(原座標)。但是可以發現相乘後，只會縮放各個x, y, z的座標後相加。<br><span>$$\begin{bmatrix}
a_1 &amp; b_1 &amp; c_1 \\
a_2 &amp; b_2 &amp; c_2 \\
a_3 &amp; b_3 &amp; c_3 \\
\end{bmatrix}
\begin{bmatrix}
x_{old}\\
y_{old}\\
z_{old}\\
\end{bmatrix}
= 
\begin{bmatrix}
a_1 \cdot x_{old} + b_1 \cdot y_{old} + c_1 \cdot z_{old}\\
a_2 \cdot x_{old} + b_2 \cdot y_{old} + c_2 \cdot z_{old}\\
a_3 \cdot x_{old} + b_3 \cdot y_{old} + c_3 \cdot z_{old}\\
\end{bmatrix}$$</span><!-- Has MathJax --><br>在這裡加上一個四維座標空間的概念，圖學中常常使用到，但實際上仍是三維的一個輔助法。<br><span>$$\begin{bmatrix}
a_1 &amp; b_1 &amp; c_1 &amp; w_1 \\
a_2 &amp; b_2 &amp; c_2 &amp; w_2 \\
a_3 &amp; b_3 &amp; c_3 &amp; w_3 \\
a_4 &amp; b_4 &amp; c_4 &amp; w_4 \\
\end{bmatrix}
\begin{bmatrix}
x_{old}\\
y_{old}\\
z_{old}\\
w_{old}\\
\end{bmatrix}
= 
\begin{bmatrix}
a_1 \cdot x_{old} + b_1 \cdot y_{old} + c_1 \cdot z_{old} + w_1 \cdot w_{old} \\
a_2 \cdot x_{old} + b_2 \cdot y_{old} + c_2 \cdot z_{old} + w_2 \cdot w_{old} \\
a_3 \cdot x_{old} + b_3 \cdot y_{old} + c_3 \cdot z_{old} + w_3 \cdot w_{old} \\
a_4 \cdot x_{old} + b_4 \cdot y_{old} + c_4 \cdot z_{old} + w_4 \cdot w_{old} \\
\end{bmatrix}$$</span><!-- Has MathJax --><br>擴充成四維空間後，這樣看起來沒什麼意義。但是當在不必要的地方填入0，還有必要的地方填入1後，就會變以下這樣。<br><span>$$\begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; w_1 \\
0 &amp; 1 &amp; 0 &amp; w_2 \\
0 &amp; 0 &amp; 1 &amp; w_3 \\
0 &amp; 0 &amp; 0 &amp; 1 \\
\end{bmatrix}
\begin{bmatrix}
x_{old}\\
y_{old}\\
z_{old}\\
1\\
\end{bmatrix}
= 
\begin{bmatrix}
1 \cdot x_{old} + 0 \cdot y_{old} + 0 \cdot z_{old} + w_1 \cdot 1 \\
0 \cdot x_{old} + 1 \cdot y_{old} + 0 \cdot z_{old} + w_2 \cdot 1 \\
0 \cdot x_{old} + 0 \cdot y_{old} + 1 \cdot z_{old} + w_3 \cdot 1 \\
0 \cdot x_{old} + 0 \cdot y_{old} + 0 \cdot z_{old} + 1 \cdot 1 \\
\end{bmatrix}
=
\begin{bmatrix}
x_{old} + w_1\\
y_{old} + w_2\\
z_{old} + w_3\\
1\\
\end{bmatrix}$$</span><!-- Has MathJax --><br>這樣子就變成一個位移專用的矩陣，仍然不會用到我們擴充的第四維，但是又可以輔助三維空間的位移。</p>
<span>$$\begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 2 \\
0 &amp; 1 &amp; 0 &amp; 3 \\
0 &amp; 0 &amp; 1 &amp; -5 \\
0 &amp; 0 &amp; 0 &amp; 1 \\
\end{bmatrix}
\begin{bmatrix}
x_{old}\\
y_{old}\\
z_{old}\\
1\\
\end{bmatrix}
= 
\begin{bmatrix}
1 \cdot x_{old} + 0 \cdot y_{old} + 0 \cdot z_{old} + 2 \cdot 1 \\
0 \cdot x_{old} + 1 \cdot y_{old} + 0 \cdot z_{old} + 3 \cdot 1 \\
0 \cdot x_{old} + 0 \cdot y_{old} + 1 \cdot z_{old} - 5 \cdot 1 \\
0 \cdot x_{old} + 0 \cdot y_{old} + 0 \cdot z_{old} + 1 \cdot 1 \\
\end{bmatrix}
=
\begin{bmatrix}
x_{old} + 2\\
y_{old} + 3\\
z_{old} - 5\\
1\\
\end{bmatrix}$$</span><!-- Has MathJax -->
<p>以上就是位移矩陣的由來。在定位一個物體在世界座標中哪個位置時常使用。</p>
<h3 id="旋轉">旋轉</h3><p>旋轉矩陣我在<a href="/2015/08/19/座標轉換筆記/">這篇</a>文章中有寫過，因此把結果提出來，讓我們知道方程式與矩陣的關係。<br>原本的方程式如下:<br><span>$$x_{new} = x_{old} \cos \theta - y_{old} \sin \theta \\
y_{new} = x_{old} \sin \theta + y_{old} \cos \theta \\$$</span><!-- Has MathJax --><br>換成矩陣後:<br><span>$$\begin{bmatrix}
\cos{\theta} &amp; -\sin{\theta} \\
\sin{\theta} &amp; \cos{\theta}  \\
\end{bmatrix}
\begin{bmatrix}
x_{old}\\
y_{old}\\
\end{bmatrix}
= 
\begin{bmatrix}
x_{old} \cos{\theta} - y_{old} \sin{\theta} \\
x_{old} \sin{\theta} + y_{old} \cos{\theta} \\
\end{bmatrix}$$</span><!-- Has MathJax --></p>
<p>如果要放到3D世界來使用，有兩點要思考。</p>
<ol>
<li>這樣的旋轉在3D世界中是屬於依照X還是Y還是Z呢? Ans: Z</li>
<li>要位移怎麼辦?只能是XYZ軸嗎?<br>這篇文章介紹每個大概，只介紹依照XYZ軸的旋轉，如果是依照<a href="http://inside.mines.edu/fs_home/gmurray/ArbitraryAxisRotation/" title="AARotation" target="_blank" rel="external">任意軸</a>，或更勝之是<a href="http://www.3dgep.com/understanding-quaternions/" title="四元數" target="_blank" rel="external">四元數</a>，這些較適合以後開文章討論，或是請讀者至參考連結去閱讀，如果有問題可以提出來討論，Dowen在寫這篇文章的時候都已閱讀完畢。</li>
</ol>
<blockquote><h4 id="歐拉角">歐拉角</h4><p>以旋轉矩陣來進行旋轉的集合統稱為歐拉角，順序有先XYZ, ZYX ,YZX, XZY…各種組合。如果是以<strong>世界座標</strong>的XYZ旋轉，不會產生問題。但是如果以<strong>物體座標</strong>的話，就會產生意想不到的問題。怎麼說呢? 拿起手機，螢幕對著自己，當作Z軸指向自己，上方當作Y軸，右方當作X軸。 那如果以ZXY的矩陣來旋轉會產生什麼問題呢?首先以Z轉任意角度，X轉<strong>90度</strong>，之後Y的選轉軸，與Z就重合了。有人會想物體的Z也在變阿? 實際上，電腦藉由矩陣運算的時候，轉完Z之後，轉了X後，Z已經不會有任何改變，因為那是之前轉完的。而X轉了90度後，Y剛好與原Z軸重合，導致Y與Z軸只能轉一樣的方向。 這就是所謂的<a href="https://www.youtube.com/watch?v=zc8b2Jo7mno" target="_blank" rel="external">萬向鎖(Gimbal Lock)</a></p>
</blockquote>
<p>先擴充成以Z軸的三維旋轉<br><span>$$\begin{bmatrix}
\cos{\theta} &amp; -\sin{\theta} &amp; 0\\
\sin{\theta} &amp; \cos{\theta}  &amp; 0\\
0 &Tab;&Tab;     &amp; 0             &amp; 1\\
\end{bmatrix}$$</span><!-- Has MathJax --></p>
<p>以上讀者可以以之前的方式自行證明。接下來要擴充成四維空間，原因是之前說過的，為了位移的技巧。<br><span>$$\begin{bmatrix}
\cos{\theta} &amp; -\sin{\theta} &amp; 0 &amp; 0\\
\sin{\theta} &amp; \cos{\theta}  &amp; 0 &amp; 0\\
0 &Tab;&Tab;     &amp; 0             &amp; 1 &amp; 0\\
0 &Tab;&Tab;     &amp; 0             &amp; 0 &amp; 1\\
\end{bmatrix}$$</span><!-- Has MathJax --><br>順便列出剩下兩個以x與y的旋轉。</p>
<p>以Y軸旋轉<br><span>$$\begin{bmatrix}
\cos{\beta}  &amp; 0 &amp; \sin{\beta} &amp; 0\\
0            &amp; 1 &amp; 0           &amp; 0\\
-\sin{\beta} &amp; 0 &amp; \cos{\beta} &amp; 0\\
0 &Tab;&Tab;     &amp; 0 &amp; 0           &amp; 1\\
\end{bmatrix}$$</span><!-- Has MathJax --></p>
<p>以X軸旋轉<br><span>$$\begin{bmatrix}
1 &amp; 0             &amp; 0            &amp; 0\\
0 &amp; \cos{\alpha}  &amp; -sin{\alpha} &amp; 0\\
0 &amp; \sin{\alpha}  &amp; cos{\alpha}  &amp; 0\\
0 &amp; 0             &amp; 0            &amp; 1\\
\end{bmatrix}$$</span><!-- Has MathJax --></p>
<p>順便一提，如果自己推出的矩陣與上不符，不一定是錯的，只是在圖學中，上方是符合右手定則，逆時針旋轉，以Z軸旋轉來說，就是Z不變, X軸朝向Y軸移動形成看起來逆時針的旋轉。(圖學中Z軸永遠指向螢幕外，也就是指向自己)</p>
<h3 id="縮放">縮放</h3><p>縮放其實很簡單，不論你原本的點是在負向的部分還是正向，經由縮放後，會靠近0，或者遠離0，矩陣如下。<br><span>$$\begin{bmatrix}
x_{old}\\
y_{old}\\
z_{old}\\
1\\
\end{bmatrix}
\begin{bmatrix}
S_x &amp; 0 &amp; 0   &amp; 0\\
0 &amp; S_y &amp; 0   &amp; 0\\
0 &amp; 0&Tab;&amp; S_z &amp; 0\\
0 &amp; 0   &amp; 0   &amp; 1\\
\end{bmatrix}
=
\begin{bmatrix}
S_x x_{old}\\
S_y y_{old}\\
S_z z_{old}\\
1\\
\end{bmatrix}$$</span><!-- Has MathJax --></p>
<h2 id="相關座標空間">相關座標空間</h2><p>使用OpenGL需要接觸到許多三維座標空間，看到以下列出這麼多，也不需要太慌張，其實都是一點一點演變而來的，這一連串的座標空間都息息相關。</p>
<h3 id="笛卡爾座標">笛卡爾座標</h3><p>這是我們最常使用到的座標系統，直角坐標系統，也稱為笛卡爾座標系統，這個就不多做說明。</p>
<img src="/images/OBT4/Cartesian.png" width="420">
<h3 id="齊次座標">齊次座標</h3><p>先來看下面這張圖。<br>
<div class="container-outside-div">
		<img src="http://image5.tuku.cn/wallpaper/Landscape%20Wallpapers/10666_1280x800.jpg" style="width: 420px">
		<p>圖片引用自<a href="http://www.tuku.cn" target="_blank" rel="external">圖庫網</a></p>
</div>
<br>鐵軌旁邊兩條平行的軌道，理應是一直線不會交合的，但是現實世界中，他們越遠就會越相近。而距今約兩百年前的天文學家 奧古斯特·費迪南德·莫比烏斯（August Ferdinand Möbius) 發展了齊次座標的概念，使用齊次概念的座標系統，都要在其維度多增加一維。 (而剛好的，增加一維又可以讓位移矩陣發揮作用，這不知道是不是一種數學的巧合呢?)</p>
<p>而齊次與笛卡爾的關係如下:<br>二維:<br>$ (x,y,w) = \left( \frac{x}{w},\frac{y}{w} \right)  $<br>三維: (投影矩陣部分詳細說明, 先看二維就好)<br>$ (x,y,z,w) = \left( \frac{x}{w},\frac{y}{w},\frac{z}{w} \right)  $<br>舉例如下:<br>$ (2,3,5)_h = \left(\frac{2}{5},\frac{3}{5}\right)_c $<br>$ (4,6,10)_h = \left(\frac{4}{10},\frac{6}{10}\right)_c = \left(\frac{2}{5},\frac{3}{5}\right)_c $<br>$ (2a,3a,5a)_h = \left(\frac{2}{5},\frac{3}{5}\right)_c $</p>
<p>利用齊次的概念讓兩條平行線有交集:<br><span>$$\begin{cases}
Ax + By + C = 0 \\
Ax + By + D = 0
\end{cases}$$</span><!-- Has MathJax --><br>在上方的笛卡爾空間中，這兩條線除非 $ C = D $ ，否則不可能有交集。<br>而利用齊次的概念就是將 $ w $ 放進來，把 $ x $ 取代為 $ \frac{x}{w} $，$ y $ 取代為 $ \frac{y}{w} $<br>而w 的範圍是 $ 1 \ge w &gt; 0$ ，其意義是遠近的意思。 越遠$w$值越小。<br><span>$$\begin{cases}
A \frac{x}{w} + B \frac{y}{w} + C = 0 \\
A \frac{x}{w} + B \frac{y}{w} + D = 0
\end{cases}$$</span><!-- Has MathJax --><br>如果 $ w = 1 $ 那一切都沒變，但若 $ w $趨近於0，就會發生一件事，前兩項參數的值過於巨大，導致C,D的影響完全不重要。不過換個角度看的話會更明顯，這次改成這樣。<br><span>$$\begin{cases}
Ax + By + C \times w = 0 \\
Ax + By + D \times w = 0
\end{cases}$$</span><!-- Has MathJax --><br>這樣很容易就可看出越遠C,D值越小，導致最後匯聚於一點的狀況。這就是在笛卡爾空間中運用齊次座標的效果。</p>
<p>以圖來表示:</p>
<img src="https://s3.amazonaws.com/grapher/exports/ec89zgtdv0.png" width="420">
<ul>
<li>紅線: $r = 5x + 50$</li>
<li>藍線: $b = 5x - 50$</li>
<li>綠色: $g = 5x - 50 \times w$</li>
<li>紫色: $p = 5x - 50 \times w$</li>
<li>$w$(深度): $w = 1 - x/100$ (只要看x = 0 ~ 100的範圍, 超過都不在實驗範圍)<br>上圖表示到$ x = 100$這個點的時候會聚在一起，而且是逐漸匯聚。</li>
</ul>
<h3 id="物體座標">物體座標</h3><p>不管事人物、花瓶、球，任何物體在建置的時候都有一個<strong>Local Space</strong>，稱為物體座標，在這物體座標中，建置的每個點都是相對於原點。通常都會把物體的每個頂點都定義在原點附近，因為這不是真正在遊戲或場警中出現的位置，所以在這個空間建置的模型，只需要專注建模即可。</p>
<img src="/images/OBT4/local.png" width="300">
<h3 id="世界座標">世界座標</h3><p>把物體放到世界座標(<strong>World Space</strong>)，我們利用一個矩陣稱為<strong>Model矩陣</strong>。這是圖學常見的MVP矩陣中的第一段，將物體定位於世界的空間中。而Model矩陣可以由上方所提出的旋轉、位移、縮放所組成，但要注意順序是有差別的，正常我們會先縮放，再旋轉、在位移，原因是如果先位移，那旋轉轉的就不是模組本身，而是將模組以旋轉的方式位移。另外先旋轉，後縮放，在位移也是等可以的，如果不是這兩種方式，那就是有其他用途。總之，經過Model矩陣後，物體就會被放到世界場景中該有的位置。</p>
<img src="/images/OBT4/world.png" width="420">
<h3 id="視覺座標">視覺座標</h3><p>世界座標轉到視覺座標(<strong>View Space</strong>)，這裡使用<strong>View矩陣</strong>，而這空間也可以說是攝影機空間，將所有世界座標中的物體，經過旋轉位移後，移動到攝影機的面前，也就是世界的長相都取決於攝影機的位置，拍攝角度。跟現實不同的是，現實是攝影機移動拍攝世界，圖學中是世界移動到攝影機面前，或是移出攝影機外。</p>
<img src="/images/OBT4/view.png" width="420">
<p>右下角那個攝影機拍攝畫面就是視覺座標的樣子。其實這裡以圖來表示不是很正確，因為還經過了正交投影，不懂正交投影的話，就先假設圖中就是正確的，因為正交實際上做的事不多。</p>
<h3 id="投影座標">投影座標</h3><p>最後來到的這個座標叫做(<strong>Clip Space</strong>)，使用到的矩陣稱為<strong>Projection矩陣</strong>，原理是透過兩個平面，一個近，一個遠，然後這個範圍內的物體影像(頂點)投射到近平面上，如果是線性投射(透視投影)，就會是<strong>仿</strong>現實生活的畫面，但也是我們最習慣看到的畫面，如下。</p>

<div class="container-outside-div">
	<div class="container-inside-div">
		<img src="/images/OBT4/pers-near.png" style="width: 300px">
		<p>近物</p>
	</div>
	<div class="container-inside-div">
		<img src="/images/OBT4/pers-far.png" style="width: 300px">
		<p>遠物</p>
	</div>
</div>

<p>而如果是經過正交投影，直接將範圍透的物體作投射，那麼就不會有遠近的感覺。不過正交投影自然有它存在的價值，像是做影子就會使用到，初學者需要多多消化理解這部分，因為正交視覺上頗為不直觀。</p>

<div class="container-outside-div">
	<div class="container-inside-div">
		<img src="/images/OBT4/ortho-near.png" style="width: 300px">
		<p>近物</p>
	</div>
	<div class="container-inside-div">
		<img src="/images/OBT4/ortho-far.png" style="width: 300px">
		<p>遠物</p>
	</div>
</div>

<h2 id="攝影機">攝影機</h2><p>一台攝影機，有拍攝角度跟攝影機的座標位置。這邊就先從簡單的攝影機位置在視覺座標中，與View矩陣到底有什麼關係說起。開始前先說明，畫面是從投影矩陣過後在xyz為-1 ~ 1之間的影像，所以移動到攝影機前這個動作，可能會聯想到，那原本的攝影機在哪? 為何要移動攝影機? 其實預設是有一個假攝影機，他會將那些頂點位於-1 ~ 1之間的描繪出來，所以之前的<a href="/2016/08/06/OpenGL-Beginner-Tutorial-3-Pipeline">文章</a>才可以顯示出三角形，而這裡是要給讀者知道，要自訂一台攝影機所需要的知識。</p>
<h3 id="攝影機的位置">攝影機的位置</h3><p>假設一攝影機位於$(1,2,3)$的三維空間中，那若要以該攝影機為視覺出發點該如何做呢? 簡單來說，就是朝向$(-1,-2,-3)$位移就好了，這裡的疑點應該是，攝影機都在$(1,2,3)$了，為何還要移動$(-1,-2,-3)$呢?原因是假定的這台攝影機，實際上也不存在，所有的視野都只會看到位於$(-1,-1,-1)$到$(1,1,1)$這個正方體(或稱為Normalize Device Coordination)中，也因此正中心是在$(0,0,0)$，也就是說要假裝正中心在$(1,2,3)$的話，那就是這世界的每個物體都要往反方向的$(1,2,3)$移動，也就是$(-1,-2,-3)$。舉個實際的例子，當一台攝影機往右邊平移拍攝的時候，攝影機<strong>假設</strong>沒再動，那也就是拍攝的物體往左方移動了，讓你誤以為往右平移拍攝，上面的原理就是如此，以為攝影機從原點$(0,0,0)$跑到$(1,2,3)$，實際上是所有物體從世界座標的$(x,y,z)$變成$(x-1,y-2,z-3)$，產生攝影機在動的錯覺。對了，不管哪個矩陣都是對每個物體的世界座標做相乘，而不是對攝影機這個抽象物體。<br>而攝影機關於位置的位移矩陣如下:<br><span>$$\begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; -Camera_x \\
0 &amp; 1 &amp; 0 &amp; -Camera_y \\
0 &amp; 0 &amp; 1 &amp; -Camera_z \\
0 &amp; 0 &amp; 0 &amp; 1 \\
\end{bmatrix}$$</span><!-- Has MathJax --></p>
<h3 id="攝影機的拍攝角度">攝影機的拍攝角度</h3><p>攝影機的拍攝角度，基本上是由三個向量所定義而成的，攝影機的前方<span>$\vec{C}_f$</span><!-- Has MathJax -->，攝影機的上方<span>$\vec{C}_u$</span><!-- Has MathJax -->，攝影機的右方<span>$\vec{C}_r$</span><!-- Has MathJax -->，有了這三個方向的向量，就可以知道，要怎麼旋轉，不過與其說是旋轉，不如說是<strong>座標轉換</strong>，將原本軸是$(1,0,0)$,$(0,1,0)$,$(0,0,1)$的三個互相垂直的向量，轉換成以<span>$\vec{C}_r$</span><!-- Has MathJax -->, <span>$\vec{C}_u$</span><!-- Has MathJax -->, <span>$\vec{C}_f$</span><!-- Has MathJax -->為xyz軸的空間。<br>首先要先了解原座標空間在矩陣上是如何表示。<br><span>$$\begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 0\\
0 &amp; 1 &amp; 0 &amp; 0\\
0 &amp; 0 &amp; 1 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 1\\
\end{bmatrix}
\begin{bmatrix}
x_{old}\\
y_{old}\\
z_{old}\\
1\\
\end{bmatrix}
=
\begin{bmatrix}
x_{old}\\
y_{old}\\
z_{old}\\
1\\
\end{bmatrix}$$</span><!-- Has MathJax --><br>上方斜對角為一的稱為單位矩陣，撇去名詞，就是一個塞了XYZ三軸單位向量的矩陣，且多了一個不會用到的擴充四維。那麼在攝影機座標空間中是如何看待原座標空間中的點呢? 關係如下:<br><span>$$\begin{bmatrix}
C_r.x &amp; C_r.y &amp; C_r.z &amp; 0\\
C_u.x &amp; C_u.y &amp; C_u.z &amp; 0\\
C_f.x &amp; C_f.y &amp; C_f.z &amp; 0\\
0     &amp; 0     &amp; 0     &amp; 1\\
\end{bmatrix}
\begin{bmatrix}
x_{old}\\
y_{old}\\
z_{old}\\
1\\
\end{bmatrix}
=
\begin{bmatrix}
C_r.x \cdot x_{old} + C_r.y \cdot y_{old} + C_r.z \cdot z_{old} \\
C_u.x \cdot x_{old} + C_u.y \cdot y_{old} + C_u.z \cdot z_{old} \\
C_f.x \cdot x_{old} + C_f.y \cdot y_{old} + C_f.z \cdot z_{old} \\
1 &Tab;&Tab;&Tab;&Tab;&Tab;&Tab;&Tab;&Tab;&Tab;&Tab;&Tab;&Tab;&Tab;&Tab;&Tab;&Tab;\\
\end{bmatrix}$$</span><!-- Has MathJax --><br>而換算矩陣就是<span>$\vec{C}_r$</span><!-- Has MathJax -->, <span>$\vec{C}_u$</span><!-- Has MathJax -->, <span>$\vec{C}_f$</span><!-- Has MathJax -->所構成的。也就是說如果此時你要在X軸移動一單位，需要$(C_r.x, C_r.y, C_r.z)$個單位才能在畫面上向右移動一格，忘了提到，這裡所使用到的攝影機向量都是單位向量。</p>
<p>而如果要使用攝影機的話，文末提供的GLM有一個名為<code>LookAt(cameraPositon, target, cameraUp)</code>，這個原理就是上方所講的，只是這裡的三個參數，就可以產生出三個向量，像是<span>$\vec{C}_f$</span><!-- Has MathJax --> 只要利用 target - cameraPositon之後Normalize就可以達成，而<span>$\vec{C}_u$</span><!-- Has MathJax -->就是cameraUp，最後的<span>$\vec{C}_r$</span><!-- Has MathJax -->只要利用<span>$\vec{C}_u \times \vec{C}_f$</span><!-- Has MathJax -->就可以得到最後的向量了，這裡外積的順序是yz相乘得x，如果是zy就會是-x，若無法理解請拿原本的$(0,1,0) \times (0,0,1)$來做測試。</p>
<p>而要操縱攝影機則要了解攝影機旋轉的概念，主要有三種旋轉方式。一個是Pitch，抬頭與低頭的概念。一個是Yaw，左轉與右轉的概念。一個是Roll，趴睡的時候，你的頭就會轉這種以鼻子為軸的方式旋轉。而概念圖如下:</p>
<img src="/images/OBT4/Camera.png" width="420">
<p>在座標系統上的概念如下:<br>
<div class="container-outside-div">
	<div class="container-inside-div">
		<img src="/images/OBT4/pitch.gif" style="width: 50%">
		<p>Pitch</p>
	</div>
	<div class="container-inside-div">
		<img src="/images/OBT4/yaw.gif" style="width: 50%">
		<p>Yaw</p>
	</div>
</div>
</p>
<p>Pitch(抬頭)，即是向量往Y軸移動，若假設向量長度為r，那XYZ三者與Pitch夾角$\theta$關係如下:<br><span>$$\begin{align}
y&amp; = r\sin{\theta}\\
x&amp; = r\cos{\theta} \cdot \cos{plane}\\
z&amp; = r\cos{\theta} \cdot \sin{plane}\\
\end{align}$$</span><!-- Has MathJax --><br>其中 plane 代表的是原本X,Z在平面上的分量，而且是常數。不過如果加入Yaw(回頭)的話，就可以改變這個情況，如上圖所示，Yaw代表的是X朝向Z的旋轉關係，所以只要把 plane 改為 $ \alpha $ 就可以完成Pitch與Yaw的攝影機。<br><span>$$\begin{align}
y&amp; = r\sin{\theta}\\
x&amp; = r\cos{\theta} \cdot \cos{\alpha}\\
z&amp; = r\cos{\theta} \cdot \sin{\alpha}\\
\end{align}$$</span><!-- Has MathJax --><br>至於Roll這個旋轉，較少出現在攝影機的移動中，不管遊戲還是編輯器中，所使用的攝影機多半是Pitch與Yaw的組合，也因此這裡不會有萬向鎖的問題。不過這裡要注意的是這裡的Yaw跟Pitch與歐拉角中的旋轉不相等，因為本文中的Pitch一次就動到了xyz三點的值，算是一種對任意軸的旋轉，而之前所介紹的旋轉公式是對固定軸，</p>
<h2 id="透視投影與正交投影">透視投影與正交投影</h2>
<div class="container-outside-div">
	<div class="container-inside-div">
		<img src="/images/OBT4/pers-near.png" style="width: 300px">
		<p>透視投影 近物</p>
	</div>
	<div class="container-inside-div">
		<img src="/images/OBT4/pers-far.png" style="width: 300px">
		<p>透視投影 遠物</p>
	</div>
</div>


<div class="container-outside-div">
	<div class="container-inside-div">
		<img src="/images/OBT4/ortho-near.png" style="width: 300px">
		<p>正交投影 近物</p>
	</div>
	<div class="container-inside-div">
		<img src="/images/OBT4/ortho-far.png" style="width: 300px">
		<p>正交投影 遠物</p>
	</div>
</div>

<p>回顧一下之前看到的兩張圖，透視投影接近現實，越遠的物體就會越小。正交投影屬於理想向量世界，不管物體遠近，都會顯示他原本定義的大小。而不管透視或正交假想上都有一個遠盤(far plane)，跟一個近盤(near plane)，在兩盤之間的物體就會出現在畫面上，超出兩盤的都無法看見。</p>
<img src="/images/OBT4/persproj.png" width="300">
<p>而這個階段的目的是為了將View階段的<span>$x_{view},y_{view},z_{view},1$</span><!-- Has MathJax -->，轉換到Projection階段的<span>$x_{clip},y_{clip},z_{clip},w_{clip}$</span><!-- Has MathJax -->，順道一提，clip space也可以稱為projection space。概念公式如下:<br><span>$$\begin{pmatrix}
x_{ndc} \\
y_{ndc} \\
z_{ndc} \\
1       \\
\end{pmatrix}
=
\begin{pmatrix}
\frac{x_{clip}}{w_{clip}} \\
\frac{y_{clip}}{w_{clip}} \\
\frac{z_{clip}}{w_{clip}} \\
\frac{w_{clip}}{w_{clip}} \\
\end{pmatrix}$$</span><!-- Has MathJax --><br>算出Clip space後，交給OpenGL會自動用透視除法(perspective devision)，來轉成NDC空間的座標，而上方除以$w$的概念就是透視除法，也是齊次座標中所使用到的概念，因為<span>$w_{clip}$</span><!-- Has MathJax -->，其實是view space的<span>$z_{view}$</span><!-- Has MathJax -->。</p>
<h3 id="透視投影">透視投影</h3><p>先從困難的透視投影講起，之後正交就簡單了，在這個階段主要有四個步驟，當然化為程式都是一個數學式，不過要理解透視投影的每個步驟就要一步一步分開詳細探討。</p>
<h4 id="第一步:X的線性投影">第一步:X的線性投影</h4>
<div class="container-outside-div">
	<div class="container-inside-div">
		<img src="/images/OBT4/persUp.png" style="width: 300px">
		<p>從上方看透視投影區</p>
	</div>
	<div class="container-inside-div">
		<img src="/images/OBT4/persSide.png" style="width: 300px">
		<p>從側邊看透視投影區</p>
	</div>
</div>

<p>上圖中，e代表的是View Space中的座標，p代表projection座標，要注意的是，這並不是clip space，就是說這個階段是投影座標。<br>這個階段要產出的線性轉換如下:<br><span>$$\begin{align}
x_p&amp; : x_e = -n : ze \\
x_p&amp; = -n\frac{x_e}{z_e} = \frac{n x_e}{-z_e} \\
y_p&amp; : y_e = -n : ze \\
y_p&amp; = -n\frac{y_e}{z_e} = \frac{n y_e}{-z_e} \\
\end{align}$$</span><!-- Has MathJax --></p>
<h4 id="第二步:壓縮至-1_~_1">第二步:壓縮至-1 ~ 1</h4><p>為何要壓縮至-1 ~ 1呢?這不是clip space到NDC空間才要由OpenGL轉換的嗎? 沒錯，不過投影階段直接就運算到最終的空間NDC，最後用了齊次座標的技巧，才讓NDC變回clip空間，接下來可以這技巧是如何變的，不過為什麼不直接給NDC給OpenGL，要換成clip space，個人臆測是因為OpenGL對深度有一個叫做Depth test或Stencil test的部分會用到。</p>
<p>首先將投影座標與Normalize後座標(NDC)的關係找出來:</p>

<div class="container-outside-div">
	<div class="container-inside-div">
		<img src="/images/OBT4/perswidthnormal.png" style="width: 300px">
	</div>
	<div class="container-inside-div">
		<img src="/images/OBT4/pershightnormal.gif" style="width: 300px">
	</div>
</div>

<p>上方轉換成數學關係式如下:<br><span>$$\begin{align}
x_n&amp; = a x_p + b\\
x_p&amp; = r, x_n = 1 \\
1&amp; = ar + b\\
x_p&amp; = l, x_n = -1\\
-1&amp; = al + b\\
a&amp; = \frac{1-(-1)}{r-l} ,
b = \frac{l+r}{l-r} \\
x_n&amp; = \frac{2}{r-l}x_p + \frac{l+r}{l-r}\\
\end{align}$$</span><!-- Has MathJax --></p>
<p>側視圖的公式大同小異:<br><span>$$\begin{align}
y_n&amp; = a y_p + c\\
y_p&amp; = t, y_n = 1 \\
1&amp; = ar + c\\
t_p&amp; = l, t_n = -1\\
-1&amp; = ab + c\\
a&amp; = \frac{1-(-1)}{t-b} ,
c = \frac{b+t}{b-t} \\
y_n&amp; = \frac{2}{t-b}x_p + \frac{b+t}{b-t}\\
\end{align}$$</span><!-- Has MathJax --></p>
<h4 id="第三步:第一步代入第二步">第三步:第一步代入第二步</h4><p>到這個步驟是view -&gt; proj -&gt; ndc -&gt; clip，第一步找出view -&gt; proj的關係，第二步找出proj -&gt; ndc的關係，這裡當然就是要找出ndc -&gt; clip的關係，以view表示，畢竟要將view轉到clip。那就直接進入數學式吧。<br><span>$$\bbox[5px,border:2px solid black] 
{
\begin{equation}
\begin{split}
x_n =&amp; \frac{2}{r-l}x_p + \frac{l+r}{l-r} &amp; x_p = \frac{n x_e}{-z_e}\\
&Tab;=&amp; \frac{2}{r-l}x_p - \frac{l+r}{r-l}
&Tab;= \frac{2 \cdot \frac{n x_e}{-z_e} }{r-l} - \frac{l+r}{r-l}\\
&Tab;=&amp; \frac{2 n x_e}{(r-l)(-z_e)} - \frac{l+r}{r-l}
&Tab;= \frac{\frac{2n}{r-l} \cdot x_e}{-z_e} - \frac{l+r}{r-l}\\
&Tab;=&amp; \frac{\frac{2n}{r-l} \cdot x_e}{-z_e} + \frac{\frac{l+r}{r-l} \cdot z_e}{-z_e}
&Tab;= \frac{ \frac{2n}{r-l}\cdot x_e + \frac{l+r}{r-l} \cdot z_e }{-z_e}\\
&Tab;=&amp; \frac{x_c}{-z_e} &amp; x_c = \frac{2n}{r-l}\cdot x_e + \frac{l+r}{r-l} \cdot z_e \\
\end{split}
\end{equation}
}$$</span><!-- Has MathJax --><br>根據以上的NDC與View之間的關係，得到一個新的Clip座標<span>$x_c$</span><!-- Has MathJax -->，有發現為什麼$-z$會被留在那嗎? 那就是將齊次座標的概念留下，不過只看一個還看不出來，當每個座標都需要$-z$的輔助後，就會理解這樣的用意。不過還是要強調，這個步驟是將NDC的概念退回Clip的步驟，比較不是偏數學的概念，算是程式技巧才有Clip Space的存在。而y的方面就如同上方，讀者可以自行推導，直接進入下一步。</p>
<h4 id="第四步:建立矩陣與填補矩陣未知部分">第四步:建立矩陣與填補矩陣未知部分</h4><span>$$\begin{bmatrix} 
x_c \\
y_c \\
z_c \\
w_c \\
\end{bmatrix}
= 
\begin{bmatrix} 
\frac{2n}{r-l} &amp; 0&Tab;&Tab;&Tab;    &amp; -\frac{r+l}{r-l} &amp; 0\\
0 &Tab;&Tab;&Tab;   &amp; \frac{2n}{t-b} &amp; \frac{t+b}{t-b} &amp; 0\\ 
0&Tab;&Tab;&Tab;   &amp; 0&Tab;&Tab;&Tab;    &amp; A &Tab;&Tab;&Tab;  &amp; B\\
0&Tab;&Tab;&Tab;   &amp; 0 &Tab;&Tab;&Tab;    &amp; -1 &Tab;&Tab;&Tab;  &amp; 0\\
\\
\end{bmatrix}
\begin{bmatrix}
x_e\\
y_e\\
z_e\\
w_e\\
\end{bmatrix}$$</span><!-- Has MathJax -->
<p>首先前兩行(row)，就是我們第三步所推導的，而第四行只有一個$-1$，是因為已經決定讓<span>$-z_e$</span><!-- Has MathJax -->，當作最後要做透視除法的參數，也許可以等第三行推完之後，參考本節一開始所說的概念公式，來理解這段。而第三行前兩個值是$0$，因為透視投影主要是將投影空間中依照深度距離不同位置的$x$,$y$，投影到近盤上，既然其他人都依賴<span>$z_e$</span><!-- Has MathJax -->，<span>$z_e$</span><!-- Has MathJax -->也就不會依賴回去。因此只剩下兩個未知參數需要處理，而View Space中<span>$w_e$</span><!-- Has MathJax -->是$1$，因此B成為輔助參數，讓<span>$z_c$</span><!-- Has MathJax -->與<span>$z_e$</span><!-- Has MathJax -->建立線性關係，就變成以下的形式。<br><span>$z_c = Az_e + B$</span><!-- Has MathJax --><br>而要轉換回可以逆推導的情形，必須轉回NDC，因為clip space本身並沒有實質意義，這部分對剛接觸的人會有很多困惑，因為前面都是正向工程，到這裡要推<span>$z_c$</span><!-- Has MathJax -->卻要用逆向工程，返回<span>$z_n$</span><!-- Has MathJax -->，在回到<span>$z_c$</span><!-- Has MathJax -->。<br><span>$z_n = \frac{z_c}{w_c} = \frac{Az_e + B}{-z_e} = \frac{A z_e + B}{-z_e}$</span><!-- Has MathJax --><br>其實這段Dowen嘗試過正向推導，不過由於沒有<span>$z_p$</span><!-- Has MathJax -->與<span>$z_e$</span><!-- Has MathJax -->的何關係式，所以推不出來。<br><span>$$\begin{align}
z_n&amp; = \frac{A z_e + B}{-z_e}\\
z_n&amp; = -1, z_e = -n \\
-n&amp; = -An + B\\
z_n&amp; = l, z_e = -f\\
-f&amp; = -Af + B\\
a&amp; = -\frac{f+n}{f-n} ,
b = -\frac{2fn}{f-n} \\
z_n&amp; = \frac{ -\frac{f+n}{f-n}z_e-\frac{2fn}{f-n} }{-z_e}\\
\end{align}$$</span><!-- Has MathJax --></p>
<p>回到矩陣的形式如下:<br><span>$$\begin{bmatrix} 
x_c \\
y_c \\
z_c \\
w_c \\
\end{bmatrix}
= 
\begin{bmatrix} 
\frac{2n}{r-l} &amp; 0&Tab;&Tab;&Tab;    &amp; -\frac{r+l}{r-l} &amp; 0\\
0 &Tab;&Tab;&Tab;   &amp; \frac{2n}{t-b} &amp; \frac{t+b}{t-b} &amp; 0\\ 
0&Tab;&Tab;&Tab;   &amp; 0&Tab;&Tab;&Tab;    &amp; -\frac{f+n}{f-n}&amp; -\frac{2fn}{f-n}\\
0&Tab;&Tab;&Tab;   &amp; 0 &Tab;&Tab;&Tab;    &amp; -1 &Tab;&Tab;&Tab;  &amp; 0\\
\\
\end{bmatrix}
\begin{bmatrix}
x_e\\
y_e\\
z_e\\
w_e\\
\end{bmatrix}$$</span><!-- Has MathJax --></p>
<p>以上是最終矩陣，將View轉成Clip空間，而通常不會使用以上的矩陣。我們通常使用的是正方形近盤，所以將$t = r = -l = -b$，矩陣會變換如下:<br><span>$$\begin{bmatrix} 
\frac{n}{r} &amp; 0&Tab;&Tab;&Tab;    &amp; 0 &amp; 0\\
0 &Tab;&Tab;&Tab;   &amp; \frac{n}{r} &amp; 0 &amp; 0\\ 
0&Tab;&Tab;&Tab;   &amp; 0&Tab;&Tab;&Tab;    &amp; -\frac{f+n}{f-n}&amp; -\frac{2fn}{f-n}\\
0&Tab;&Tab;&Tab;   &amp; 0 &Tab;&Tab;&Tab;    &amp; -1 &Tab;&Tab;&Tab;  &amp; 0\\
\\
\end{bmatrix}
\begin{bmatrix}
x_e\\
y_e\\
z_e\\
w_e\\
\end{bmatrix}$$</span><!-- Has MathJax --><br>接下來檢視一下OpenGL會用到的GLM函式<code>glm::perspective(fov, aspect, near, far)</code>。其矩陣原理如下:</p>
<span>$$\begin{bmatrix} 
X_{spec} &amp; 0&Tab;&Tab;&Tab;    &amp; 0 &amp; 0\\
0 &Tab;&Tab;&Tab;   &amp; Y_{spec} &amp; 0 &amp; 0\\ 
0&Tab;&Tab;&Tab;   &amp; 0&Tab;&Tab;&Tab;    &amp; -\frac{f+n}{f-n}&amp; -\frac{2fn}{f-n}\\
0&Tab;&Tab;&Tab;   &amp; 0 &Tab;&Tab;&Tab;    &amp; -1 &Tab;&Tab;&Tab;  &amp; 0\\
\\
\end{bmatrix}$$</span><!-- Has MathJax -->
<span>$$\begin{align}
Y_{spec}&amp; = \cot({fov/2}) \\
X_{spec}&amp; = \frac{Y_{spec}}{aspect}
\end{align}$$</span><!-- Has MathJax -->
<ul>
<li>fov: field of view，視野的意思，通常視野是$45°$，根據自定義而有所不同，至於為何是$cot$，看一下上上個矩陣，對邊分之鄰邊，而且視野只有一半。</li>
<li>aspect: 視窗的比例，若視窗是500x500 這裡只要給1.0即可，若是800x600這裡就要給定800/600，在畫面就會顯示正常，原因是整個畫面要顯示-1 ~ 1的正方體，那x的部分就得多壓縮一點。</li>
</ul>
<h3 id="正交投影">正交投影</h3><img src="/images/OBT4/ortho.png" width="300">
<p>正交投影，直接將點平行投影到投影近盤上，所以不會有<span>$x_p$</span><!-- Has MathJax -->與<span>$x_e$</span><!-- Has MathJax -->不同的問題，直接做線性轉換至NDC。<br><span>$$\begin{align}
x_n&amp; = \frac{2}{r-l}x_e - \frac{r+l}{r-l}\\
y_n&amp; = \frac{2}{t-b}y_e - \frac{t+b}{t-b}\\
z_n&amp; = \frac{-2}{f-n}z_e - \frac{f+n}{f-n}\\
\end{align}$$</span><!-- Has MathJax --><br>由於<span>$x_e$</span><!-- Has MathJax -->與 <span>$x_n$</span><!-- Has MathJax --> 沒有像透視投影跟深度有關，所以矩正很簡單的如下:<br><span>$$\begin{bmatrix} 
\frac{2}{r-l} &amp; 0&Tab;&Tab;&Tab;    &amp; -\frac{r+l}{r-l} &amp; 0\\
0 &Tab;&Tab;&Tab;   &amp; \frac{2}{t-b} &amp; -\frac{t+b}{t-b} &amp; 0\\ 
0&Tab;&Tab;&Tab;   &amp; 0&Tab;&Tab;&Tab;    &amp; -\frac{2}{f-n}&amp; -\frac{f+n}{f-n}\\
0&Tab;&Tab;&Tab;   &amp; 0 &Tab;&Tab;&Tab;    &amp; -1 &Tab;&Tab;&Tab;  &amp; 0\\
\\
\end{bmatrix}$$</span><!-- Has MathJax --></p>
<h2 id="直線與曲線">直線與曲線</h2><h3 id="直線">直線</h3><p>直線，最常想到的第一個公式是 $ y = ax + b $ ，但是利用向量表示，在電腦繪圖中反而會比較適合做Intepolation。向量表示如下:<br><span>$$\begin{align}
P&amp; = A + t\vec{D}  \\
\vec{D}&amp; = (B - A) \\
P&amp; = A + t(B-A)    \\
\end{align}$$</span><!-- Has MathJax --><br>上方的公式意義是表示A要往B移動，如果t = 1，表示點P已經從A移動到B。小於1的任何數值都代表還在路途中，這樣的表示法比原本的表示法的移動模式要直觀許多。</p>
<img src="/images/OBT4/line.png" width="420">
<blockquote><h4 id="Intepolation(內插)">Intepolation(內插)</h4><p>根據現有的資訊進行階段式前進，除了有關線的公式，利用向量步步前進的概念外，OpenGL在顏色上也有這樣的機制。Fragment Shader階段時，若使用者定義三個點各自的顏色，未給定其他像素的意義，OpenGL就會進行顏色的內插。假設有AB兩點，一者紅，一者藍，OpenGL就會自動用內插的方式進行顏色計算，概念如此: <span>$Color_{new} = Color_A + t(Color_B - Color_A) = (1-t)Color_A + tColor_B$</span><!-- Has MathJax -->。而GLSL語法裡面進行這樣計算的是一個叫<code>mix(a, b, t)</code>的內建函式，專門用來處理以上的動作。</p>
</blockquote>
<h3 id="曲線">曲線</h3><p>最簡單的直線是利用兩條直線的方式混和移動而成，概念圖如下:</p>
<img src="/images/OBT4/bicurve.png" width="420">
<span>$$\begin{align}
D&amp; = A + t(B-A)&Tab;   \\
E&amp; = B + t(C-B)&Tab;   \\
P&amp; = D + t(E-D)&Tab;   \\
P&amp; = A + t(B-A) + t( B+t(C-B) - (A+t(B-A)) )&Tab;   \\
P&amp; = A + t(B-A) + Bt+t^2(C-B) - At - t^2(B-A))     \\
P&amp; = A + t(B-A + B-A) + t^2(C-B-B-A)   &Tab;&Tab;       \\
P&amp; = A + 2t(B-A) + t^2(C-2B-A)   &Tab;&Tab;           \\
\end{align}$$</span><!-- Has MathJax -->
<p>透過兩條線瞬間產生出來的點，在將這兩點做直線移動就是以上的概念，當初Dowen看了許久，到<a href="http://pomax.github.io/bezierinfo/" target="_blank" rel="external">這網站</a>才了解到為何可以這樣混合公式的最初契機。這邊小題外話，有時候數學無法理解，是因為很多網站都沒提到其細部概念，也就是最初觀察到此現象的由來或契機，只說這樣是對的，然後用一堆複雜的數學佐證，所以才導致學習有礙。</p>
<p>剛剛其實就是有名的貝茲曲線，而這裡是介紹三次貝茲曲線，如果看懂的話，不論幾次也能自己推導了。</p>
<img src="/images/OBT4/cubiccurve.png" width="420">
<span>$$\begin{align}
E&amp; = A + t(B-A)&Tab;   \\
F&amp; = B + t(C-B)&Tab;   \\
G&amp; = C + t(D-C)&Tab;   \\
H&amp; = E + t(F-E)&Tab;   \\
I&amp; = F + t(G-F)&Tab;   \\
P&amp; = H + t(I-H)&Tab;   \\
\end{align}$$</span><!-- Has MathJax -->
<p>二次懂，三次問題就不大。這裡就提一個貝茲曲線上的專有名詞<strong>Control Point</strong>，像是上方二次貝茲的控制點就是ABC，三次是ABCD，藉由更改這些點的位置，就可以改變曲線角度，理解控制點，就可以微調算出想要的曲線角度了。</p>
<h2 id="GLM">GLM</h2><p><a href="http://glm.g-truc.net/0.9.7/index.html" target="_blank" rel="external">GLM(OpenGL Mathematics)</a>，是一個專門為OpenGL設計的數學函式庫，特別的是，它只需要將標頭檔加入，不需要引入lib，或是dll之類的組態檔，就可以引入環境中，所以不會有環境建置的困擾，首先只需要將<a href="https://github.com/g-truc/glm/releases" target="_blank" rel="external">標頭檔資料夾</a>放到適當的位置，之後加入Include，就完成基本的載入。</p>
<img src="/images/OBT4/includeglm.png" width="420">
<p>之後加入泛用的程式標頭。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;glm/glm.hpp&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;glm/gtc/matrix_transform.hpp&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;glm/gtc/type_ptr.hpp&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>測試一下矩陣乘法，理解一下概念。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 helloMatrix = glm::mat4(glm::vec4(<span class="number">1.0</span>), glm::vec4(<span class="number">2.0</span>), glm::vec4(<span class="number">3.0</span>), glm::vec4(<span class="number">4.0</span>));</span><br><span class="line"><span class="keyword">int</span> mlenght = <span class="number">16</span>;</span><br><span class="line">glm::vec4 helloVector = glm::vec4(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line"><span class="keyword">int</span> vlenght = helloVector.length();</span><br><span class="line"><span class="keyword">float</span> *matrix = glm::value_ptr(helloMatrix);</span><br><span class="line"><span class="keyword">float</span> *<span class="built_in">vector</span> = glm::value_ptr(helloVector);</span><br><span class="line">glm::vec4 vresult = helloMatrix * helloVector;</span><br><span class="line"><span class="keyword">float</span> *result = glm::value_ptr(vresult);</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Matrix:"</span> &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mlenght; i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; matrix[i] &lt;&lt; <span class="string">","</span>;</span><br><span class="line">	<span class="keyword">if</span>((i+<span class="number">1</span>)%<span class="number">4</span> == <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Vector:"</span> &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vlenght; i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">vector</span>[i] &lt;&lt; <span class="string">","</span>;</span><br><span class="line">	<span class="keyword">if</span> (i % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; i != <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Result:"</span> &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vlenght; i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; result[i] &lt;&lt; <span class="string">","</span>;</span><br><span class="line">	<span class="keyword">if</span> (i % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; i != <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>這會產生的結果如下:</p>
<img src="/images/OBT4/glmresult.png" width="420">
<p>有發現結果不是正常的矩陣運算嗎?因為OpenGL在定義矩陣的時候都是先定義Column，再來才是Row，用數學來檢視一下結果的原因吧。<br><span>$$\begin{bmatrix}
1&amp;1&amp;1&amp;1 \\
2&amp;2&amp;2&amp;2 \\
3&amp;3&amp;3&amp;3 \\
4&amp;4&amp;4&amp;4 \\
\end{bmatrix}
\begin{bmatrix}
1       \\
0&Tab;&Tab;\\
1&Tab;&Tab;\\
0&Tab;    \\
\end{bmatrix}
=
\begin{bmatrix}
2       \\
4&Tab;&Tab;\\
6&Tab;&Tab;\\
8&Tab;    \\
\end{bmatrix}$$</span><!-- Has MathJax --><br>上面如果是想要的結果，但實際上定義的向量是這樣被矩陣擺放的:<br><span>$$\begin{bmatrix}
1&amp;2&amp;3&amp;4 \\
1&amp;2&amp;3&amp;4 \\
1&amp;2&amp;3&amp;4 \\
1&amp;2&amp;3&amp;4 \\
\end{bmatrix}
\begin{bmatrix}
1       \\
0&Tab;&Tab;\\
1&Tab;&Tab;\\
0&Tab;    \\
\end{bmatrix}
=
\begin{bmatrix}
4       \\
4&Tab;&Tab;\\
4&Tab;&Tab;\\
4&Tab;    \\
\end{bmatrix}$$</span><!-- Has MathJax --><br>因此，如果要修正的話必須要改成如下形式:</p>
<pre><code class="cpp"><span class="comment">//glm::mat4 helloMatrix = glm::mat4(glm::vec4(1.0), glm::vec4(2.0), glm::vec4(3.0), glm::vec4(4.0));</span>
glm::mat4 helloMatrix = glm::mat4(glm::vec4(<span class="number">1.0</span>,<span class="number">2.0</span>,<span class="number">3.0</span>,<span class="number">4.0</span>), glm::vec4(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>),
</code></pre>
<p>這樣結果就修改完成了。</p>
<img src="/images/OBT4/glmcorrectresult.png" width="420">
<p>而<code>glm::value_ptr</code>這個函式，原始的定義是根據傳入GLM的參數，根據其最原始型態傳回該參數的指標。而本範例是傳入GLM矩陣、向量，使其傳回浮點數指標，或說是一段float陣列。</p>
<h2 id="其他">其他</h2><h4 id="四元數"><a href="http://www.3dgep.com/understanding-quaternions/" title="四元數" target="_blank" rel="external">四元數</a></h4><h4 id="不同的曲線"><a href="https://www.youtube.com/watch?v=LFFPbBe7aAs" target="_blank" rel="external">不同的曲線</a></h4><h4 id="攝影機加入Roll旋轉"><a href="http://in2gpu.com/2016/03/14/opengl-fps-camera-quaternion/" target="_blank" rel="external">攝影機加入Roll旋轉</a></h4><h2 id="結語">結語</h2><p>在研究OpenGL上面會碰到很多數學，但是如果找對適當的文章或是解釋，就能打通那任督二脈。而Dowen就是那種需要自己尋找能理解的文章的人。因為有些網站，或是學校的教學方式，就是教學者自己沒咀嚼好，就抽象地教給學習者，所以導致教者不知學者所礙，中間有代溝。Dowen寫的教學文主要是想解決這樣的代溝，所以努力地做圖跟以自己曾經的困惑，自問自答的方式來幫助有同樣困惑的讀者。不過比較差的是以藍寶書的章節為出文的篇幅，如果以後有足夠的經驗與時間，也許會重新製作一份真正的初心者教學吧!</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="開始前介紹">開始前介紹</h2><p>這一章節主要是介紹一些數學的基礎，如果發現哪個部分不熟的話，最好能親自磨練一下，因為以後常常需要的時候，如果不懂箇中原理，那麼在偵錯或是實作上，會遇到一些麻煩。當然領悟過後能寫起來是最推薦的方式，以後忘了的時候瞟一眼就行了。初學者如果看不懂本篇的話，可以暫且跳過無妨，當有用到再回頭看，因為現在的文章是搭配官方藍寶書的章節推進，而藍寶書比較適合中階以上閱讀者，所以本篇對初學者來說應該很吃力。<br>接下來會介紹的內容基本上有:</p>
<ul>
<li>向量</li>
<li>反射與折射</li>
<li>矩陣</li>
<li>相關座標系統</li>
<li>攝影機</li>
<li>透視投影與正交投影</li>
<li>直線與曲線</li>
<li>GLM</li>
</ul>]]>
    
    </summary>
    
      <category term="Euler Angle" scheme="http://tokenyet.github.io/tags/Euler-Angle/"/>
    
      <category term="GLM" scheme="http://tokenyet.github.io/tags/GLM/"/>
    
      <category term="Intepolation" scheme="http://tokenyet.github.io/tags/Intepolation/"/>
    
      <category term="OpenGL" scheme="http://tokenyet.github.io/tags/OpenGL/"/>
    
      <category term="OpenGL Tutorial" scheme="http://tokenyet.github.io/tags/OpenGL-Tutorial/"/>
    
      <category term="OpenGL介紹" scheme="http://tokenyet.github.io/tags/OpenGL%E4%BB%8B%E7%B4%B9/"/>
    
      <category term="OpenGL入門教學" scheme="http://tokenyet.github.io/tags/OpenGL%E5%85%A5%E9%96%80%E6%95%99%E5%AD%B8/"/>
    
      <category term="OpenGL基礎" scheme="http://tokenyet.github.io/tags/OpenGL%E5%9F%BA%E7%A4%8E/"/>
    
      <category term="OpenGL教學" scheme="http://tokenyet.github.io/tags/OpenGL%E6%95%99%E5%AD%B8/"/>
    
      <category term="Reflect" scheme="http://tokenyet.github.io/tags/Reflect/"/>
    
      <category term="Refract" scheme="http://tokenyet.github.io/tags/Refract/"/>
    
      <category term="Rotation" scheme="http://tokenyet.github.io/tags/Rotation/"/>
    
      <category term="bezier curve" scheme="http://tokenyet.github.io/tags/bezier-curve/"/>
    
      <category term="canera" scheme="http://tokenyet.github.io/tags/canera/"/>
    
      <category term="clip space" scheme="http://tokenyet.github.io/tags/clip-space/"/>
    
      <category term="cubic bezier curve" scheme="http://tokenyet.github.io/tags/cubic-bezier-curve/"/>
    
      <category term="local space" scheme="http://tokenyet.github.io/tags/local-space/"/>
    
      <category term="lookat" scheme="http://tokenyet.github.io/tags/lookat/"/>
    
      <category term="matrix" scheme="http://tokenyet.github.io/tags/matrix/"/>
    
      <category term="ndc" scheme="http://tokenyet.github.io/tags/ndc/"/>
    
      <category term="orthographic" scheme="http://tokenyet.github.io/tags/orthographic/"/>
    
      <category term="perspective" scheme="http://tokenyet.github.io/tags/perspective/"/>
    
      <category term="perspective division" scheme="http://tokenyet.github.io/tags/perspective-division/"/>
    
      <category term="projection" scheme="http://tokenyet.github.io/tags/projection/"/>
    
      <category term="scale" scheme="http://tokenyet.github.io/tags/scale/"/>
    
      <category term="translate" scheme="http://tokenyet.github.io/tags/translate/"/>
    
      <category term="vector" scheme="http://tokenyet.github.io/tags/vector/"/>
    
      <category term="view space" scheme="http://tokenyet.github.io/tags/view-space/"/>
    
      <category term="世界座標" scheme="http://tokenyet.github.io/tags/%E4%B8%96%E7%95%8C%E5%BA%A7%E6%A8%99/"/>
    
      <category term="內插" scheme="http://tokenyet.github.io/tags/%E5%85%A7%E6%8F%92/"/>
    
      <category term="內積" scheme="http://tokenyet.github.io/tags/%E5%85%A7%E7%A9%8D/"/>
    
      <category term="反射" scheme="http://tokenyet.github.io/tags/%E5%8F%8D%E5%B0%84/"/>
    
      <category term="向量" scheme="http://tokenyet.github.io/tags/%E5%90%91%E9%87%8F/"/>
    
      <category term="外積" scheme="http://tokenyet.github.io/tags/%E5%A4%96%E7%A9%8D/"/>
    
      <category term="座標系統" scheme="http://tokenyet.github.io/tags/%E5%BA%A7%E6%A8%99%E7%B3%BB%E7%B5%B1/"/>
    
      <category term="折射" scheme="http://tokenyet.github.io/tags/%E6%8A%98%E5%B0%84/"/>
    
      <category term="攝影機" scheme="http://tokenyet.github.io/tags/%E6%94%9D%E5%BD%B1%E6%A9%9F/"/>
    
      <category term="歐拉角" scheme="http://tokenyet.github.io/tags/%E6%AD%90%E6%8B%89%E8%A7%92/"/>
    
      <category term="正交投影" scheme="http://tokenyet.github.io/tags/%E6%AD%A3%E4%BA%A4%E6%8A%95%E5%BD%B1/"/>
    
      <category term="物體座標" scheme="http://tokenyet.github.io/tags/%E7%89%A9%E9%AB%94%E5%BA%A7%E6%A8%99/"/>
    
      <category term="直線" scheme="http://tokenyet.github.io/tags/%E7%9B%B4%E7%B7%9A/"/>
    
      <category term="矩陣" scheme="http://tokenyet.github.io/tags/%E7%9F%A9%E9%99%A3/"/>
    
      <category term="透視投影" scheme="http://tokenyet.github.io/tags/%E9%80%8F%E8%A6%96%E6%8A%95%E5%BD%B1/"/>
    
      <category term="透視除法" scheme="http://tokenyet.github.io/tags/%E9%80%8F%E8%A6%96%E9%99%A4%E6%B3%95/"/>
    
      <category term="OpenGL" scheme="http://tokenyet.github.io/categories/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenGL 藍寶入門教學 3: Pipeline]]></title>
    <link href="http://tokenyet.github.io/2016/08/06/OpenGL-Beginner-Tutorial-3-Pipeline/"/>
    <id>http://tokenyet.github.io/2016/08/06/OpenGL-Beginner-Tutorial-3-Pipeline/</id>
    <published>2016-08-06T06:47:28.000Z</published>
    <updated>2016-08-25T09:54:11.118Z</updated>
    <content type="html"><![CDATA[<h2 id="開始前介紹">開始前介紹</h2><p>為了讓有興趣的初學者能踏入這個領域，Dowen把以前觀念上不清楚的部分全部在pipeline中補齊許多。縱使如此也是可能有疑點的部分，如果有疑問盡量在文章下方留言，有空一定回覆:D。</p>
<h2 id="CPU到GPU第一階段_-_Vertex_Shader的資料傳送">CPU到GPU第一階段 - Vertex Shader的資料傳送</h2><p>GPU在開始執行Vertex Shader前面，有一個動作稱為<em>Vertex Fetching</em>，這個動作會將我們在程式中寫的一個稱為<em>Vertex Attribute</em>的部分讀出來，而後傳送至GPU處。其中GPU必須由 <code>layout (location = 0) in</code> 來定義輸入要從GPU的哪個位置中取出，而CPU則是藉由 <code>glVertexAttribXXX(0, data)</code> 來將資料填入記憶體等待<em>Vertex Fetching</em>到GPU中layout的部分。<br><a id="more"></a></p>
<h3 id="動手做_-_CPU_to_GPU">動手做 - CPU to GPU</h3><p>首先在迴圈中加入要傳遞的資料與其對應的function，都是以 <code>glVertexAttrib</code> 開頭的傳遞函式。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">glBindVertexArray(vertexArrayObject);</span><br><span class="line"></span><br><span class="line">GLfloat data[] = &#123;</span><br><span class="line">	(<span class="keyword">float</span>)<span class="built_in">sin</span>(glfwGetTime()) * <span class="number">0.5f</span>,</span><br><span class="line">	(<span class="keyword">float</span>)<span class="built_in">cos</span>(glfwGetTime()) * <span class="number">0.6f</span>,</span><br><span class="line">	<span class="number">0.0f</span>, <span class="number">0.0f</span></span><br><span class="line">&#125;;</span><br><span class="line">glVertexAttrib4fv(<span class="number">0</span>, data);</span><br><span class="line">glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">glBindVertexArray(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p><em>double glfwGetTime(void)</em> : 回傳時間參數</p>
<p><em>void glVertexAttrib[X/fm/vt]()</em></p>
<ul>
<li>X  - 有1,2,3,4等數字表達。</li>
<li>fm - 以i代表整數,f代表浮點數,還有其他d,s…需自行參考Spec。</li>
<li>v  - 代表vector，也就是傳入陣列。</li>
</ul>
<p>結果:<br><img src="/images/OBT3/MoveTri.jpg" width="420"></p>
<h3 id="小優化">小優化</h3><p>知道如何傳遞資料給GPU後，我們將三角形的資料提取出來，來從外部傳入三角形Vertex，而不要直接在Shader中寫死。首先將Shader改成以下都從外部傳入的形式。但是這次不用 <code>glVertexAttrib</code>來做連結了，原因稍後解釋。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#version 450 core</span></span><br><span class="line">layout (location = <span class="number">0</span>) in vec4 offset;</span><br><span class="line">layout (location = <span class="number">1</span>) in vec4 vertex;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	gl_Position = vertex + offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>回到Code的部分，這次在迴圈外的地方改成以下的形式。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GLuint vertexArrayObject;</span><br><span class="line">glGenVertexArrays(<span class="number">1</span>, &amp;vertexArrayObject); <span class="comment">//glCreateVertexArrays(1, &amp;vertexArrayObject); // only for 4.5</span></span><br><span class="line">GLuint vertexBufferObject;</span><br><span class="line">GLfloat vertices[] = &#123;</span><br><span class="line">	<span class="number">0.25</span>,-<span class="number">0.25</span>,<span class="number">0.5</span>,<span class="number">1.0</span>,</span><br><span class="line">	-<span class="number">0.25</span>,-<span class="number">0.25</span>,<span class="number">0.5</span>,<span class="number">1.0</span>,</span><br><span class="line">	<span class="number">0.25</span>,<span class="number">0.25</span>,<span class="number">0.5</span>,<span class="number">1.0</span></span><br><span class="line">&#125;;</span><br><span class="line">glBindVertexArray(vertexArrayObject);</span><br><span class="line">glGenBuffers(<span class="number">1</span>, &amp;vertexBufferObject);</span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, vertexBufferObject);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line">glVertexAttribPointer(<span class="number">1</span>, <span class="number">4</span>, GL_FLOAT, GL_FALSE, <span class="number">4</span> * <span class="keyword">sizeof</span>(GLfloat), (GLvoid*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">1</span>);</span><br><span class="line">glBindVertexArray(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p><em>void glGenVertexArrays(GLsizei n, GLuint *arrays)</em></p>
<ul>
<li>第一個參數代表陣列是產生幾個VAO物件。</li>
<li>第二個用來承接產生物件的陣列, 之前提過收到的是物件編號，也就是數字陣列。</li>
</ul>
<p><em>void glBindVertexArray(GLuint array)</em> </p>
<ul>
<li>變數名稱有點不適當，這裡是代表綁定VAO物件。</li>
</ul>
<p><em>void glGenBuffers(GLsizei n, GLuint * buffers)</em></p>
<ul>
<li>與 glGenVertexArrays 的概念一樣，只是這裡是產生Buffer物件。</li>
</ul>
<p><em>void glBindBuffer(GLenum target, GLuint buffer)</em></p>
<ul>
<li>第一個是指定綁定在哪種容器上。</li>
<li>第二個是將先前產生的buffer綁定到適當的容器中，範例是綁定為VBO物件(稍後說明VBO)，雖然沒有GL_BUFFER_OBJECT，但有GL_ARRAY_BUFFER，別讓名稱誤解，所以不用太針對GL_ARRAY_BUFFER這個名詞深究。</li>
</ul>
<p><em>void glBufferData(GLenum target, GLsizeiptr size, const GLvoid * data, GLenum usage)</em></p>
<ul>
<li>指定容器，會將後續參數資料填入指定容器中。</li>
<li>分配需要多少空間。</li>
<li>要傳遞的資料</li>
<li>這項有很多選擇性，只提出基本以下 GL_STREAM_DRAW, GL_STATIC_DRAW, GL_DYNAMIC_DRAW，如果data是會更動改變，使用DYNAMIC，而不會則用STATIC，若是只會更改一次的串流用途就會用STREAM。</li>
</ul>
<p><em>void glVertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid * pointer)</em></p>
<ul>
<li>指定要進入shader的哪個location中。</li>
<li>指定要一次讀幾個值。</li>
<li>指定值的型態。</li>
<li>指定是否要Normailize (壓縮到-1 ~ 1 的意思)。</li>
<li>指定讀完資料後，應該移動的距離。</li>
<li>指定一開始讀資料的時候，要移動的距離。</li>
</ul>
<p><em>void glEnableVertexAttribArray(GLuint index)</em></p>
<ul>
<li>開啟要使用的location，不開啟的化，Shader該location無法傳入任何值。</li>
</ul>
<p>結果(沒變):<br><img src="/images/OBT3/MoveTri.jpg" width="420"></p>
<h3 id="VBO_與_VAO">VBO 與 VAO</h3><p>VBO的概念是將資料存到記憶體中(<code>glBufferData</code>)，而且可以指定GPU要以什麼樣的方式讀取資料，也就是利用 <code>glVertexAttribPointer</code> 來指定讀取方式，而這樣的好處是什麼? 如果你的陣列之中長得像以下這樣。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GLfloat data[] = &#123;</span><br><span class="line">    <span class="comment">// position          // color          // normalize</span></span><br><span class="line">	<span class="number">0.25</span>,-<span class="number">0.25</span>,<span class="number">0.5</span>,<span class="number">1.0</span>,<span class="number">1.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">1.0f</span>,</span><br><span class="line">	-<span class="number">0.25</span>,-<span class="number">0.25</span>,<span class="number">0.5</span>,<span class="number">1.0</span>,<span class="number">0.0f</span>,<span class="number">1.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">1.0f</span>,</span><br><span class="line">	<span class="number">0.25</span>,<span class="number">0.25</span>,<span class="number">0.5</span>,<span class="number">1.0</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">1.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">1.0f</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>一次將許多資料都定義在一起，那麼就很輕鬆就可在送至GPU的時候做好哪筆資料應該傳入哪個location。而這裡要回到之前說的所有事情都是將<em>Vertex Attribute</em>傳送至GPU。只是這次利用Buffer指定格式後，<em>Vertex Fetching</em>會幫我們切割好後，以<em>Vertex Attribute</em>的格式傳入，符合之前所呼應的說明。</p>
<p>這裡就繪製一下VBO的概念。<br><img src="/images/OBT3/VBO.png" width="800"><br>這裡搭配上方的程式碼解說對照，這裡提offset，為之前沒說到的部分，假設說此時要將RGB的值，指定到Shader中<em>location = 2</em>的位置，這裡就要再加上 <code>glVertexAttribPointer(2, 3, GL_FLOAT, GL_FALSE, 7 * sizeof(GLfloat), (GLvoid*)(4 * sizeof(GLfloat)) );</code> 也就是指定第二個location，讀取長度3，整體長度7，起始跳過4個單位長。那麼每次移動7個單位長就會移動到第二排第4個單位長，因此就成為專門將RGB給分配到location = 2的格式了。 最後別忘記啟用就好 <code>glEnableVertexAttribArray(2)</code> 。</p>
<p>好了，剛剛稍微轉了一點理解，但其實VBO實際上的概念是這樣，到 <code>glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW)</code> 這裡就已經算結束，也就是說VBO只是配置一個記憶體的空間而已，這樣的空間或說緩衝區時常被用來連結VAO然後傳送至GPU，所以有時候比較難分清楚誰的責任是什麼，而且現代OpenGL強制使用VAO，所以你用VBO就必使用VAO。 因此這裡說明白，VBO只是個空間，VAO則是將VBO做格式定位與欄位啟動的地方，也就是說 <code>glEnableVertexAttribArray</code> 跟 <code>glVertexAttribPointer</code> 是VAO的責任。</p>
<p>這部分最後稍微想一下, VBO與VAO可否一對多? 多對一? 這答案都是肯定的，VAO參考多個VBO空間的值，或多個VAO參考同個空間的值，都是可以做到的事。</p>
<h2 id="Tessellation">Tessellation</h2><p>Tessellation是將<em>複雜面</em>(high-order primitive)，而什麼是<em>複雜面</em>，舉例多邊形或<em>Patch</em>等等頂點很多的都是複雜面。而為了使用Tessellation，我們不管是三角形、矩形、多邊形，通通要以Patch的形式傳入，因此Patch是一個為了讓Tessellation知道你要使用他的一個包裹，不管裡面包的是幾邊形，總而言之就是要讓Tessellation知道是個Patch才能進行細分的動作。而這個部分主要有三個階段，第一個階段<em>Tessellation Control Shader</em>屬於可程式，用來接收Vertex Shader的輸出後，定義切割表面的一些參數，並且將資料傳送到下一個階段。第二個階段<em>Tessellation Engine</em>屬於固定流程，得到參數後，依照演算法將一個Patch詳細切割，之後將這些新的點以三角形或四邊形的形式傳入下個階段。第三個階段<em>Tessellation Evaluation Shader</em>屬於可程式，這個階段得到的三角形的點是屬於<em>barycentric coordinate</em>空間的座標，而矩形是在<em>Bilinear interpolation</em>所構成x,y範圍0~1的空間中。由於這部分並非初學，而且屬於<strong>選擇性實作</strong>，所以這裡看不懂可以先知道概念即可。</p>

<div class="container-outside-div">
		<img src="/images/OBT3/tesselation.png" style="width: 420px">
		<p>Tessellation Triangle</p>
</div>

<h2 id="Geometry_Shader">Geometry Shader</h2><p>Geometry Shader是在要進入光柵(Rasterization)之前的階段，屬於<strong>選擇性實作</strong>的階段，因此也比較偏難需要另外講的文章，主要運作的模式是接收到一個primitive的數量後執行一次，也就是如果接收三角形則是收到三個頂點後執行一次，而這個階段能做的就是對你收到的點做些調整，舉個簡單的例子就是輸入一個三角形，這個階段可以新增一些點，修改一些點，變成輸出星星的形狀，這部分以後的文章會在探討。</p>

<div class="container-outside-div">
		<img src="/images/OBT3/geometry.png" style="width: 420px">
		<p>Tessellation + Geometry Triangle</p>
</div>

<h2 id="Primitive_Assembly,_Clipping,_Rasterization">Primitive Assembly, Clipping, Rasterization</h2><p>這幾個階段都是屬於Fixed的部分，操作者在這些階段無法觸及內容，所以這裡就講理論上這幾個階段的功用。</p>
<h3 id="Primitive_Assembly">Primitive Assembly</h3><p>將收到的點做組裝，像是找在primitive緩衝區中找到代表直線的區塊，假設那區塊有12個連續頂點，那就會轉換成11條直線。</p>
<h3 id="Clipping">Clipping</h3><p>這邊有一段重要的數學觀念，就是要理解<em>Homogeneous Coordinate System</em>跟<em>Normalize Device Coordinate</em>，還有透視投影(Perspective Proejction)在這之間的關係，這裡也需另外開文解釋，簡單來說我們若要了解3D空間，這個概念就不可或缺，以上幾個概念都是要在會在實作中會碰到的部分，OpengGL的這個階段在數學上是只講Homogeneous空間中的X,Y,Z除以W而已，此動作稱為Projective Division，該動作後就會到NDC空間中了。因此我們要有弄出XYZW的方法，以後的文章會提到。最後如果轉換的點超出NDC範圍就會被Clipping掉，以免浪費GPU運算速度。</p>
<h3 id="Viewport_Transformation">Viewport Transformation</h3><p>Viewport代表的是我們所定義的視窗大小，而這階段是將NDC空間那些x,y,z屬於 -1 ~ 1的座標拉伸至整個視窗上，而他對應的轉換公式如下。</p>
<span>$\begin{pmatrix}     \mathbf{x_w} \\     \mathbf{y_w}  \\     \mathbf{z_w}  \\    \end{pmatrix} = \begin{pmatrix}     \frac{P_x}{2}x_d + o_x \\     \frac{P_y}{2}y_d + o_y   \\     \frac{f-m}{2}z_d + \frac{n+f}{2}  \\    \end{pmatrix}$</span><!-- Has MathJax -->
<p>以上公式根據<br>void glViewport(GLint x,GLint y, GLsizei width, GLsizei height); 與 void glDepthRange(GLdouble nearVal, GLdouble farVal);<br>來運算，通常不會去動glDepthRange，預設是 -1 ~ 1，透視投影後不會有壓縮，而公式中 $o_x$, $o_y$ 的部分則是 $ o_x = x + \frac{weight}{2} $ 與 $ o_y = y + \frac{height}{2} $。</p>
<p>公式解釋:<br>$x_d$,$y_d$,$z_d$是NDC空間的座標，$x_w$,$y_w$,$z_w$是視窗空間的座標，$f$是遠點座標，$n$是近點座標，而前兩項是將-1 ~ 1的NDC空間拉至螢幕平面上，而最後一項則是算出螢幕中實際上代表的點深度是多少，不過這一項算完後又會被壓縮至0 ~ 1的深度給後續階段，至少我在Fragment 階段所見是這樣，而書上公式是壓縮至-1 ~ 1的公式，但書本上卻說是壓縮至 0 ~ 1，讓我思索了老半天。以下是示意圖，將x拓展至0~800, y:0~600, z:10~500。</p>

<div class="container-outside-div">
	<div class="container-inside-div">
		<img src="/images/OBT3/Vpx.svg" style="width: 300px">
	</div>
	<div class="container-inside-div">
		<img src="/images/OBT3/Vpy.svg" style="width: 300px">
	</div>
	<div class="container-inside-div">
		<img src="/images/OBT3/Vpz.svg" style="width: 300px">
	</div>
</div>

<h3 id="Culling">Culling</h3><p>一個正方體有其正面與反面，反面的當然就無法進行任何繪製，所以OpenGL有個機制，就是當定義頂點的時候，用逆時鐘(Conter Clockwise)的情況，會視為正面，而順時鐘會視為背面。 提醒一下，這個部分要特別開啟才會有效果(<code>gl_Enable(GL_CULL_FACE)</code>)，如果開啟了在定義點的時候，就必須要遵守順序。</p>

<div class="container-outside-div">
	<div class="container-inside-div">
		<img src="/images/OBT3/clockwise.png" style="width: 50%">
		<p>clockwise</p>
	</div>
	<div class="container-inside-div">
		<img src="/images/OBT3/counter-clockwise.png" style="width: 50%">
		<p>counter-clockwise</p>
	</div>
</div>

<p>也就是說如果陣列定義的是以下這樣，將會無法顯示。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GLfloat data[] = &#123;</span><br><span class="line">    <span class="comment">// position</span></span><br><span class="line">	<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>,</span><br><span class="line">	<span class="number">2.0</span>,<span class="number">2.0</span>,<span class="number">0.0</span>,</span><br><span class="line">	<span class="number">4.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>要改成以下這樣才可顯示。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GLfloat data[] = &#123;</span><br><span class="line">    <span class="comment">// position</span></span><br><span class="line">    <span class="number">2.0</span>,<span class="number">2.0</span>,<span class="number">0.0</span>,</span><br><span class="line">	<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>,</span><br><span class="line">	<span class="number">4.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其公式如下</p>
<span>$a = \frac{1}{2}\sum_{i=0}^{n-1} x_w^i y_w^{i \oplus 1} - x_w^{i \oplus 1}y_w^i$</span><!-- Has MathJax -->
<p>而概念是透過向量外積找到一個垂直的向量，若a值大於0則代表該垂直向量與指向視窗的向量夾角小於90度，則OpenGL會繪製該三角形。</p>
<h3 id="Rasterization">Rasterization</h3><p>光柵化是得知哪幾個像素是要塗上顏色的地方，其中利用的是half space的方法，而<a href="http://forum.devmaster.net/t/advanced-rasterization/6145" title="Advanced Rasterization from devmaster Nick" target="_blank" rel="external">Rasterizing Triangles from Michael Jones</a>為參考的文章，如果有時間我會開篇文章解說，當初為了解整個流程這部分特別做了點筆記。</p>
<h2 id="Fragment_Shader">Fragment Shader</h2><p>在光柵後，這個階段決定每個像素該填上的顏色為何。像是我們之前最簡單的例子像是以下這樣。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#version 450 core</span></span><br><span class="line">out vec4 color;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	color = vec4(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很簡單的填入顏色意味著不管是哪個點，就填入藍色。而Fragment Shader 的應用很多樣，光影特效主要就是在這進行，還有各種材質的貼圖，或是畫面特效後製，優化畫面的各種技巧，都是Fragment Shader可以處理的。以下是定義三個頂點的顏色後，OpenGL利用內建的Intepolate將未定義的顏色自動內插的結果。</p>

<div class="container-outside-div">
		<img src="/images/OBT3/fragment.png" style="width: 420px">
		<p>Interpolated Triangle</p>
</div>

<h2 id="Last_things">Last things</h2><p>還有一些可以參與pipeline，而且是在Fragment Shader輸出後可以進行的東西，如Framebuffer，Scissor Test, Stencil Test，Blend，在這邊簡單介紹一下，讓讀者知道要使用相關的技術應該要利用哪個技巧。<br>Framebuffer  : 一個儲存畫面的buffer，常用的方式是取出當前繪製的螢幕後，進行各種處理，通常拿取該畫面從頭開始跑一次pipeline。<br>Scissor Test : 算是很舊的技術，指定一個矩形區域，讓範圍內的像素有一些變化。<br>Stencil Test : 有點難說明，通常用來把一個物體的outline畫出，也就是類似選取到該物體的感覺，其作法是在每次畫出物體前先設定遮罩，藉由遮罩的AND\OR等計算，讓最後剩下的部分進行著色，例如一個畫出一個正方體，設定遮罩為1，然後畫出一個大一點的純色正方體，然後找遮罩不為1的就是所謂的外框。<br>Blending     : 顏色的混和，簡單可做出玻璃紙特效的效果。</p>
<p>另外還有一個Shader無關pipeline的，是名為<em>Compute Shader</em>的計算著色器，可以利用GPU平行處理特性，用來處理一些計算處理的功能。</p>
<h2 id="Review_Pipeline">Review Pipeline</h2><img src="/images/OBT3/gl_pipe.png" width="600">
<p>從這張圖來檢視一下每個流程的基本概念吧！框邊代表固定的流程，圓邊代表可程式的流程，而每個流程的基本概念是什麼最好能看著圖簡單解釋出來。</p>
<p>結語:<br>為了只是畫一個三角形付出了這麼多心力，是為了未來在畫面上可以擁有無限的操作可能。然而這篇可能有點說太多了，不過真的是什麼都想說，而且做圖真的不知道該用什麼來做比較好，如果有不錯的繪圖工具或線上繪圖(關於數學或流程的)，請告訴我。也許以後我將這篇文章砍一半，然後將每個Shader提出來分開講，或是其他方式。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="開始前介紹">開始前介紹</h2><p>為了讓有興趣的初學者能踏入這個領域，Dowen把以前觀念上不清楚的部分全部在pipeline中補齊許多。縱使如此也是可能有疑點的部分，如果有疑問盡量在文章下方留言，有空一定回覆:D。</p>
<h2 id="CPU到GPU第一階段_-_Vertex_Shader的資料傳送">CPU到GPU第一階段 - Vertex Shader的資料傳送</h2><p>GPU在開始執行Vertex Shader前面，有一個動作稱為<em>Vertex Fetching</em>，這個動作會將我們在程式中寫的一個稱為<em>Vertex Attribute</em>的部分讀出來，而後傳送至GPU處。其中GPU必須由 <code>layout (location = 0) in</code> 來定義輸入要從GPU的哪個位置中取出，而CPU則是藉由 <code>glVertexAttribXXX(0, data)</code> 來將資料填入記憶體等待<em>Vertex Fetching</em>到GPU中layout的部分。<br>]]>
    
    </summary>
    
      <category term="Clipping" scheme="http://tokenyet.github.io/tags/Clipping/"/>
    
      <category term="Fragment Shader" scheme="http://tokenyet.github.io/tags/Fragment-Shader/"/>
    
      <category term="Geometry Shader" scheme="http://tokenyet.github.io/tags/Geometry-Shader/"/>
    
      <category term="OpenGL" scheme="http://tokenyet.github.io/tags/OpenGL/"/>
    
      <category term="OpenGL Tutorial" scheme="http://tokenyet.github.io/tags/OpenGL-Tutorial/"/>
    
      <category term="OpenGL介紹" scheme="http://tokenyet.github.io/tags/OpenGL%E4%BB%8B%E7%B4%B9/"/>
    
      <category term="OpenGL入門教學" scheme="http://tokenyet.github.io/tags/OpenGL%E5%85%A5%E9%96%80%E6%95%99%E5%AD%B8/"/>
    
      <category term="OpenGL基礎" scheme="http://tokenyet.github.io/tags/OpenGL%E5%9F%BA%E7%A4%8E/"/>
    
      <category term="OpenGL教學" scheme="http://tokenyet.github.io/tags/OpenGL%E6%95%99%E5%AD%B8/"/>
    
      <category term="Rasterization" scheme="http://tokenyet.github.io/tags/Rasterization/"/>
    
      <category term="Shader" scheme="http://tokenyet.github.io/tags/Shader/"/>
    
      <category term="Tessellation" scheme="http://tokenyet.github.io/tags/Tessellation/"/>
    
      <category term="Tessellation Control Shader" scheme="http://tokenyet.github.io/tags/Tessellation-Control-Shader/"/>
    
      <category term="Tessellation Evaluation Shader" scheme="http://tokenyet.github.io/tags/Tessellation-Evaluation-Shader/"/>
    
      <category term="Viewport Transform" scheme="http://tokenyet.github.io/tags/Viewport-Transform/"/>
    
      <category term="OpenGL" scheme="http://tokenyet.github.io/categories/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenGL 藍寶入門教學 2: Strat With Triangle]]></title>
    <link href="http://tokenyet.github.io/2016/07/10/OpenGL-Beginner-Tutorial-2-Triangle/"/>
    <id>http://tokenyet.github.io/2016/07/10/OpenGL-Beginner-Tutorial-2-Triangle/</id>
    <published>2016-07-10T15:47:49.000Z</published>
    <updated>2016-08-25T08:26:55.101Z</updated>
    <content type="html"><![CDATA[<h2 id="開始前介紹">開始前介紹</h2><p>本系列文將使用<em>OpenGL 4.5</em>版本，並以作者能理解的方式教學，如有細節誤解或是講錯的部分，或跳太快應先講什麼後講什麼的地方，請不吝多多指教！謝謝！</p>
<h2 id="從點開始">從點開始</h2><p>要畫一個三角形之前，總要會在畫面上畫出一個點來。在那之前，由於使用的是Modern版OpenGL，所以做任何事都要準備兩個東西，其中一個是<em>「Vertex Array Object」</em>，簡稱<em>VAO</em>，另一個則是Shader，包含基礎的兩個稱為Vertex Shader與Fragment Shader。</p>
<ul>
<li>Shader: 其實並不只有Vertex Shader與Fragment Shader，還有Geomerty Shader、Tessellation Control Shader、Tessellation Evaluation Shader，由於屬於初階文章，所以暫不探討。而Shader其中必寫的其實只有Fragment就好，詳細請上網考查。</li>
</ul>
<p>首先在了解畫一個點需要準備貌似很多東西時，會認為很繁瑣。當深入一點後，將了解僅是一連串常用的手續，以後只要複製貼上加修改。而這裡就先示意部分的OpenGL pipeline，也就是讀者將碰到的pipeline，倘若一次列出全部流程，會猶豫一陣子。<br><img src="/images/OBT2/opengl_easy_pipeline.png" width="600"><br>上方的流程是說明，使用者可以<em>以某種方式</em>將一些資料傳給Vertex Shader，本文章目前不會先做傳資料的動作，先給一個小概念。 而傳完之後Vertex Shader仍會以<em>某種方式</em>將資料傳給流程中的下一個Shader，就是Fragment Shader，最後Fragment Shader 跑完之後會將圖片輸出到螢幕上。</p>
<p>理解到OpenGL基礎流程後，接下來就是從實作中學習，如果沒有環境的讀者可以參考<a href="/2016/07/05/OpenGL-Beginner-Tutorial-1-Setting_Up_Enviroment">上篇</a>中的Code來建立基礎環境。<br><a id="more"></a></p>
<h3 id="為OpenGL搭起一個Shader的介面">為OpenGL搭起一個Shader的介面</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GLuint vertexShader = glCreateShader(GL_VERTEX_SHADER);</span><br><span class="line">GLuint fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);</span><br><span class="line">glShaderSource(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, NULL);</span><br><span class="line">glShaderSource(fragmentShader, <span class="number">1</span>, &amp;fragmentShaderSource, NULL);</span><br><span class="line">glCompileShader(vertexShader);</span><br><span class="line">glCompileShader(fragmentShader);</span><br></pre></td></tr></table></figure>
<p>這裡必須先提到 「數字代表物件，物件管理是OpenGL的事」，OpenGL在實作上由於需符合C/C++，所以物件管理的方式是給我們從Create Function中抽一個序號，然後那個序號就是你的物件編號，有這物件編號後，我們必須<em>妥善保存</em>，然後在任何需要的時候可以跟OpenGL說要設定/刪除，先來解釋一下上面的例子就會明白。<br>首先我們準備了抽序號的物件<code>vertexShader</code>然後向<code>glCreateShader</code>要求一些東西，而這裡要求創建Vertex Shader的命令。之後要設定這個<code>vertexShader</code>物件的各種屬性，則是透過將編號(vertexShader)傳給OpenGL函式<code>glShaderSource</code>進行設定，這裡的設定是將shader的程式碼傳過去設定，可能認為傳程式碼很奇怪，但Shader就是一個給我們程式設計的地方。</p>
<p><em>void glShaderSource(GLuint shader, GLsizei count, const GLchar <em>*string, const GLint </em>length);</em></p>
<ul>
<li>第一個參數指要用哪個Shader物件。</li>
<li>第二個是Source Code的String指標跟length指標的個數。</li>
<li>第三個是程式碼整體的雙重指標。</li>
<li>第四個是你每一個指標所包含的字串長度應該讀取多少，使用NULL代表就是不指定，讀取到NULL為止。</li>
</ul>
<h3 id="Shader編譯後變成_Shader_Program">Shader編譯後變成 Shader Program</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GLuint program = glCreateProgram();</span><br><span class="line">glAttachShader(program, vertexShader);</span><br><span class="line">glAttachShader(program, fragmentShader);</span><br><span class="line">glLinkProgram(program);</span><br><span class="line">...</span><br><span class="line"><span class="comment">// in loop before you want to draw something</span></span><br><span class="line">glUseProgram(program)</span><br></pre></td></tr></table></figure>
<p>同樣是設定，這裡將剛剛產生的Shader設定在<code>program</code>裡面，接下來的<code>glLinkProgram</code>代表準備好各種Shader後的Compile，就是不給更改了，也就變成一個程式。然後在需要繪製前在使用簡單的<code>glUseProgram</code>就可以在你繪製前，套用要使用的Shader Program。</p>
<h3 id="Shader_的程式碼">Shader 的程式碼</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> GLchar *vertexShaderSource =</span><br><span class="line">	<span class="string">"#version 450 core\n"</span></span><br><span class="line">	<span class="string">"\n"</span></span><br><span class="line">	<span class="string">"void main(void)\n"</span></span><br><span class="line">	<span class="string">"&#123;\n"</span></span><br><span class="line">	<span class="string">"	gl_Position = vec4(0.0, 1.0, 0.5, 1.0);\n"</span></span><br><span class="line">	<span class="string">"&#125;\n"</span>;</span><br><span class="line"><span class="keyword">const</span> GLchar *fragmentShaderSource =</span><br><span class="line">	<span class="string">"#version 450 core\n"</span></span><br><span class="line">	<span class="string">"\n"</span></span><br><span class="line">	<span class="string">"out vec4 color;\n"</span></span><br><span class="line">	<span class="string">"\n"</span></span><br><span class="line">	<span class="string">"void main(void)\n"</span></span><br><span class="line">	<span class="string">"&#123;\n"</span></span><br><span class="line">	<span class="string">"	color = vec4(0.0, 0.0, 1.0, 1.0);\n"</span></span><br><span class="line">	<span class="string">"&#125;\n"</span>;</span><br></pre></td></tr></table></figure>
<p><code>vertexShaderSource</code>跟<code>fragmentShaderSource</code>是程式碼，就像寫程式一樣要先有Code才能用IDE編譯，而這裡是將Code丟給OpenGL編譯成一個program，如先前的範例。而如何簡單撰寫一個Shader? 根據官方所述，主要是由C下去變形，所以在C的基礎中能做，基本上都可以使用，而一個良好的Shader Code需要標明版本 <code>#version 450 core</code> 與進入點 <code>main</code> 。 有了之後以上就是最基礎的shader, <code>gl_Position</code> 代表的是以NDC空間中的位置，NDC空間簡單解釋就是說到Vertex Shader 這段，未來要做的是將三維空間轉換成NDC空間，未來講MVP矩陣的時候會提到，這裡只要想成Z指向螢幕外,Y是數學所學的上方,X是右方即可，超過1.0跟-1.0會超出螢幕範圍這樣。</p>
<h3 id="Vertex_Array_Object">Vertex Array Object</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GLuint vertexArrayObject;</span><br><span class="line">glCreateVertexArrays(<span class="number">1</span>, &amp;vertexArrayObject);</span><br></pre></td></tr></table></figure>
<p>VAO設定到Shader作為Input本篇先不做說明，但必要讓讀者知道的是，OpenGL一定要在有VAO的狀況下才能進行繪製，縱使你產生出來是空的也好。像是下面這樣。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">glUseProgram(program);</span><br><span class="line"><span class="comment">//shader.UseProgram();</span></span><br><span class="line">glBindVertexArray(vertexArrayObject);</span><br><span class="line">glDrawArrays(GL_POINTS, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">glBindVertexArray(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>使用Shader Program後綁定輸入點(VAO)，VAO的概念算是當你有Shader Program後，<code>glBindVertexArray</code>綁定的VAO就會在<code>glDrawArrays</code>的時候被傳進Shader。</p>
<p><em>void glDrawArrays(GLenum mode, GLint first, GLsizei count)</em></p>
<ul>
<li>第一個代表以何種Primitive(種類)畫你所提供的材料(VAO)。</li>
<li>第二個是VAO的起始索引，以後將資料傳給Shader時，會定義格式才有索引。</li>
<li>第三個是指定要畫的VAO索引數量。</li>
</ul>
<p>完成以上的建置後就會長得像以下的的圖。<br><img src="/images/OBT2/nothingresult.png" width="420"></p>
<p>什麼?你看不出來? 在Loop中加上<code>glPointSize(40.0f);</code>吧！<br><img src="/images/OBT2/goodresult.png" width="420"><br>將要繪製的一個像素放大四十倍後繪製，終於可以看出來了，至於原理如何，由於是在光柵化的時候做的，內建的地方就不去探討。</p>
<h3 id="Shader大整形">Shader大整形</h3><p>既然已經嘗試完畢我們就來正式開始，將Shader那一大坨的東西改成從檔案裏面讀取，再加上除錯處理，新增一個Class吧！<br><a href="https://github.com/Tokenyet/OpenGL_Basic_Tutorial/blob/master/OpenGL_Basic_Tutorial%20-%201/Shader.cpp" target="_blank" rel="external">Shader</a> Class的程式碼在這裡可以參考，由於程式碼主要的地方沒變，只有架構改變，就不討論OO的地方。</p>
<p>有了之後就可以將之前的Shader程式碼通通砍掉然後創建一個Shader Class來幫助我們輕鬆建立一個Shader Program，還有Debug的功能！之後只要將程式碼改成下方這樣就可以輕鬆使用。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Shader <span class="title">shader</span><span class="params">("shader/basic.vert", "shader/basic.frag")</span></span>;</span><br><span class="line">...</span><br><span class="line">shader.UseProgram(); <span class="comment">// in loop</span></span><br></pre></td></tr></table></figure></p>
<p>至於那兩個檔案其實並不一定要叫<code>xxx.vert</code>或<code>xxx.frag</code>，不過在OpenGL開發者中，大部分都這樣命名，而且有相關<a href="https://github.com/samizzo/nshader" target="_blank" rel="external">Highlight的插件</a>，所以讀者可以考慮習慣看看。<br>這是<a href="https://github.com/Tokenyet/OpenGL_Basic_Tutorial/blob/master/OpenGL_Basic_Tutorial%20-%201/shader/basic.vert" target="_blank" rel="external">basic.vert</a>跟<a href="https://github.com/Tokenyet/OpenGL_Basic_Tutorial/blob/master/OpenGL_Basic_Tutorial%20-%201/shader/basic.frag" target="_blank" rel="external">basic.frag</a>的程式碼。</p>
<h3 id="三角形">三角形</h3><p>接下來，正式要畫一個三角形，不過我們先用不正式的畫法，到下篇文章再慢慢推進Shader(GPU)與CPU的互動。</p>
<p>將 basic.vert 修改成以下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#version 450 core</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> vec4 vertices[<span class="number">3</span>] = vec4[<span class="number">3</span>](vec4(<span class="number">0.25</span>,-<span class="number">0.25</span>,<span class="number">0.5</span>,<span class="number">1.0</span>),</span><br><span class="line">					vec4(-<span class="number">0.25</span>,-<span class="number">0.25</span>,<span class="number">0.5</span>,<span class="number">1.0</span>),</span><br><span class="line">					vec4(<span class="number">0.25</span>,<span class="number">0.25</span>,<span class="number">0.5</span>,<span class="number">1.0</span>));</span><br><span class="line">	gl_Position = vertices[gl_VertexID];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>裡面內建的vecX是OpenGL提供你的一個型態，就是所謂的向量，這在shader中語法稱為glsl，而且很容易進行數學矩陣與向量的相乘。此外這裡有個新的東西是<code>gl_VertexID</code>，這個ID指的是，你在外面使用繪製命令的時候，代表繪製第幾個Vertex的編號。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shader.UseProgram();</span><br><span class="line">glBindVertexArray(vertexArrayObject);</span><br><span class="line">glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">glBindVertexArray(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>將loop內改成繪製三角形後，後面改成3個點，當然VAO是空的，只是強迫根據Shader的內容畫三次，每次<code>gl_VertexID</code>會根據繪製的索引而不同。</p>
<p>接下來畫面應該會長這樣子。<br><img src="/images/OBT2/finalresult.png" width="420"></p>
<p>附上最後的<a href="https://github.com/Tokenyet/OpenGL_Basic_Tutorial/blob/master/OpenGL_Basic_Tutorial%20-%201/main.cpp" target="_blank" rel="external">Code</a>。</p>
<p>小結:<br>在寫的時候，不知道怎樣算清楚怎樣不清楚，這並不是我最初的學習，有學過一段時間，現在是搭配看原文書加上自己的經驗與網路的參考來撰寫文章，滿擔心只是寫出一堆沒人看得懂的東西 :(</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="開始前介紹">開始前介紹</h2><p>本系列文將使用<em>OpenGL 4.5</em>版本，並以作者能理解的方式教學，如有細節誤解或是講錯的部分，或跳太快應先講什麼後講什麼的地方，請不吝多多指教！謝謝！</p>
<h2 id="從點開始">從點開始</h2><p>要畫一個三角形之前，總要會在畫面上畫出一個點來。在那之前，由於使用的是Modern版OpenGL，所以做任何事都要準備兩個東西，其中一個是<em>「Vertex Array Object」</em>，簡稱<em>VAO</em>，另一個則是Shader，包含基礎的兩個稱為Vertex Shader與Fragment Shader。</p>
<ul>
<li>Shader: 其實並不只有Vertex Shader與Fragment Shader，還有Geomerty Shader、Tessellation Control Shader、Tessellation Evaluation Shader，由於屬於初階文章，所以暫不探討。而Shader其中必寫的其實只有Fragment就好，詳細請上網考查。</li>
</ul>
<p>首先在了解畫一個點需要準備貌似很多東西時，會認為很繁瑣。當深入一點後，將了解僅是一連串常用的手續，以後只要複製貼上加修改。而這裡就先示意部分的OpenGL pipeline，也就是讀者將碰到的pipeline，倘若一次列出全部流程，會猶豫一陣子。<br><img src="/images/OBT2/opengl_easy_pipeline.png" width="600"><br>上方的流程是說明，使用者可以<em>以某種方式</em>將一些資料傳給Vertex Shader，本文章目前不會先做傳資料的動作，先給一個小概念。 而傳完之後Vertex Shader仍會以<em>某種方式</em>將資料傳給流程中的下一個Shader，就是Fragment Shader，最後Fragment Shader 跑完之後會將圖片輸出到螢幕上。</p>
<p>理解到OpenGL基礎流程後，接下來就是從實作中學習，如果沒有環境的讀者可以參考<a href="/2016/07/05/OpenGL-Beginner-Tutorial-1-Setting_Up_Enviroment">上篇</a>中的Code來建立基礎環境。<br>]]>
    
    </summary>
    
      <category term="OpenGL" scheme="http://tokenyet.github.io/tags/OpenGL/"/>
    
      <category term="OpenGL Tutorial" scheme="http://tokenyet.github.io/tags/OpenGL-Tutorial/"/>
    
      <category term="OpenGL介紹" scheme="http://tokenyet.github.io/tags/OpenGL%E4%BB%8B%E7%B4%B9/"/>
    
      <category term="OpenGL入門教學" scheme="http://tokenyet.github.io/tags/OpenGL%E5%85%A5%E9%96%80%E6%95%99%E5%AD%B8/"/>
    
      <category term="OpenGL基礎" scheme="http://tokenyet.github.io/tags/OpenGL%E5%9F%BA%E7%A4%8E/"/>
    
      <category term="OpenGL教學" scheme="http://tokenyet.github.io/tags/OpenGL%E6%95%99%E5%AD%B8/"/>
    
      <category term="Shader" scheme="http://tokenyet.github.io/tags/Shader/"/>
    
      <category term="Triangle" scheme="http://tokenyet.github.io/tags/Triangle/"/>
    
      <category term="VAO" scheme="http://tokenyet.github.io/tags/VAO/"/>
    
      <category term="OpenGL" scheme="http://tokenyet.github.io/categories/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenGL 藍寶入門教學 1: Setting up Environment]]></title>
    <link href="http://tokenyet.github.io/2016/07/05/OpenGL-Beginner-Tutorial-1-Setting_Up_Enviroment/"/>
    <id>http://tokenyet.github.io/2016/07/05/OpenGL-Beginner-Tutorial-1-Setting_Up_Enviroment/</id>
    <published>2016-07-05T11:14:47.000Z</published>
    <updated>2016-08-25T08:27:02.112Z</updated>
    <content type="html"><![CDATA[<h2 id="環境準備">環境準備</h2><p>開始之前還是要先講一下，讀者可以選擇各種不同的 Framework 與 Library ，像是SDL,FREEGLUT,GLFW之類的，不過不管選擇哪一種，主要的OpenGL流程都是一樣的，只是有些不同的Code或Lib必須要在官方網站自行去看，本篇要講的是GLFW+GLEW在Visual Stuido 2015中的環境建置，如果不是來建置環境的讀者可以跳過本篇，或是對GLFW與GLEW有興趣再往下閱讀。</p>
<h2 id="GLFW">GLFW</h2><p><a href="http://www.glfw.org/" target="_blank" rel="external">GLFW</a>主要是將在不同平台( Linux, Windows, Mac ) 間常用的一些使用者需求給獨立出來，這些使用者需求像是Keyboard的資訊、Mouse資訊、視窗建置….等等。將這些不同的使用者需求都統整成一個API就是其中一個GLFW在做的事，此外另一個工作是將OpenGL繪製的東西從buffer顯示到螢幕上的工作，還有一些零零總總的細節操作，最重要的是用了GLFW其實已包含OpenGL的Header，當建置好後，直接可以撰寫OpenGL的Code。</p>
<p>首先先到<a href="http://www.glfw.org/download.html" target="_blank" rel="external">GLFW官方下載</a>中找一個名為「32-bit Windows binaries」的元件 ( 注意! 64-bit Windows binaries的建議不要使用，Dowen我在建置的時候會遇到非常多問題)，抓下來後接下來就照著以下的圖片設置。</p>
<p>將GLFW放到任何認為合適的地方，之後再點選VS的專案-&gt;屬性，再點選VC++目錄，然後我們主要要變動的有以下兩個，Include目錄與程式庫目錄。<br><img src="/images/OpenGL-Beginner-Tutorial-1-Setting_Up_Enviroment/VSProperty.png" width="600"><br>設定好Include與Library。<br><a id="more"></a><br>
<div class="container-outside-div">
	<div class="container-inside-div">
		<img src="/images/OpenGL-Beginner-Tutorial-1-Setting_Up_Enviroment/glfw_include.png" style="width: 420px">
	</div>
	<div class="container-inside-div">
		<img src="/images/OpenGL-Beginner-Tutorial-1-Setting_Up_Enviroment/glfw_lib.png" style="width: 420px">
	</div>
</div>
</p>
<p>再來到連結器(Linker) -&gt; 輸入(Input) 去增加lib檔，要新增的有<code>opengl32</code>與<code>glfw3.lib</code>。<br>
<div class="container-outside-div">
	<div class="container-inside-div">
		<img src="/images/OpenGL-Beginner-Tutorial-1-Setting_Up_Enviroment/input.png" style="width: 420px">
	</div>
	<div class="container-inside-div">
		<img src="/images/OpenGL-Beginner-Tutorial-1-Setting_Up_Enviroment/glfw_input_lib.png" style="width: 350px">
	</div>
</div>
</p>
<h2 id="GLEW">GLEW</h2><p><a href="http://glew.sourceforge.net/" target="_blank" rel="external">GLEW</a>提供了Modern OpenGL中的各種函式，如果沒有使用GLEW或其他函式庫的人，在撰寫Modern OpenGL的時候就要寫類似這樣的Code。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *name = <span class="string">"glGenBuffers"</span>;</span><br><span class="line"><span class="keyword">void</span> *p = (<span class="keyword">void</span> *)wglGetProcAddress(name);</span><br><span class="line"><span class="keyword">if</span>(p == <span class="number">0</span> ||</span><br><span class="line">(p == (<span class="keyword">void</span>*)<span class="number">0x1</span>) || (p == (<span class="keyword">void</span>*)<span class="number">0x2</span>) || (p == (<span class="keyword">void</span>*)<span class="number">0x3</span>) ||</span><br><span class="line">(p == (<span class="keyword">void</span>*)-<span class="number">1</span>) )</span><br><span class="line">&#123;</span><br><span class="line">	HMODULE module = LoadLibraryA(<span class="string">"opengl32.dll"</span>);</span><br><span class="line">	p = (<span class="keyword">void</span> *)GetProcAddress(module, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在這邊取得的p代表的就是glGenBuffers的function，這段在寫Code上很常使用，Modern OpenGL使用了這樣的機制的優點是利於任何時候或是任何廠商在自己的顯卡驅動中加入新的function，缺點是我們在寫的時候就要每次去向記憶體提取function。所幸GLEW幫我們解決了這樣的問題，讓我們在使用最新的OpenGL時，免去不斷向記憶體取得新函式的手續。</p>
<p>在設定上就像GLFW一樣，要設定三個地方。<br>
<div class="container-outside-div">
	<div class="container-inside-div">
		<img src="/images/OpenGL-Beginner-Tutorial-1-Setting_Up_Enviroment/glew_include.png" style="width: 420px">
	</div>
	<div class="container-inside-div">
		<img src="/images/OpenGL-Beginner-Tutorial-1-Setting_Up_Enviroment/glew_lib.png" style="width: 420px">
	</div>
</div>
</p>
<img src="/images/OpenGL-Beginner-Tutorial-1-Setting_Up_Enviroment/glew_input.png" width="420">
<p>這樣一切的環境就準備好了。</p>
<h2 id="基礎視窗環境建置">基礎視窗環境建置</h2><p>先將<a href="https://github.com/Tokenyet/OpenGL_Basic_Tutorial/blob/master/OpenGL_Basic_Tutorial/main.cpp" target="_blank" rel="external">基礎的程式碼</a>貼到自己的環境中，直接測試看看，完成沒問題後，以下將一步一步講解每一Part。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GLEW ( help you using functions without retreiving functions )</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> GLEW_STATIC</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;GL\glew.h&gt;</span></span><br><span class="line"><span class="comment">// GLFW ( make you a windows that support opengl operation to work fine with your platform )</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;GLFW\glfw3.h&gt;</span></span><br></pre></td></tr></table></figure>
<p>這裡的GLEW_STATIC剛好對應之前的libaray <code>glew32s.lib</code>，之所以要用STATIC是因為這樣直接省去需要額外加入dll的部分，dll的部分GLEW把它分開到bin的資料夾內，當然如果讀者想使用動態的方式也無不可。</p>
<ul>
<li>Static Linking: 優點是將整個資訊全部塞進自己的binary檔。</li>
<li>Dynamic Linking: 優點是binary小，檔案各自分開乾淨。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Init and Check GLFW working properly</span></span><br><span class="line"><span class="keyword">int</span> glfwInitCheck = glfwInit();</span><br><span class="line"><span class="keyword">if</span> (glfwInitCheck == GLFW_FALSE)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"glfw initilization failed."</span> &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>這裡確定你glfw是否能夠初始化正確。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line">glfwWindowHint(GLFW_RESIZABLE, GL_FALSE);</span><br><span class="line">GLFWwindow* window = glfwCreateWindow(<span class="number">640</span>, <span class="number">480</span>, <span class="string">"OpenGL Tutorial"</span>, NULL, NULL);</span><br><span class="line"><span class="keyword">if</span> (window == <span class="keyword">nullptr</span>) <span class="comment">// window creation failed</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">glfwMakeContextCurrent(window);</span><br></pre></td></tr></table></figure>
<p><code>glfwWindowHint</code>代表的是對<code>glfwCreateWindow</code>所創造出的視窗來做事前設定，而<code>GLFW_OPENGL_PROFILE</code>設定成<code>GLFW_OPENGL_CORE_PROFILE</code>的意義是，如果我們在使用到OpenGL的function中有用到一些3.3版本之前而且新OpenGL不支援的語法的時候，就會強制跳出錯誤，這樣可以避免誤用一些過時的function。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set GLFW callback functions</span></span><br><span class="line">glfwSetErrorCallback(error_callback);</span><br><span class="line">glfwSetKeyCallback(window, key_callback);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get error from GLFW for debuging</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_callback</span><span class="params">(<span class="keyword">int</span> error, <span class="keyword">const</span> <span class="keyword">char</span>* description)</span></span>;</span><br><span class="line"><span class="comment">// Get keywords from GLFW windows</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">key_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> key, <span class="keyword">int</span> scancode, <span class="keyword">int</span> action, <span class="keyword">int</span> mods)</span></span>;</span><br></pre></td></tr></table></figure>
<p>這邊結尾為<code>callback</code>的就是我們偵測這些使用者事件的時候會觸發的function，這裡用到的技巧當然就是callback，就是將你寫的function丟進去，然後當事件觸發的時候就通知你這個function做事，然後這些可以callback的function定義都是要自行去GLFW的document查詢，像是這裡用的就是錯誤回饋<code>glfwSetErrorCallback</code>跟針對視窗的keyboard回饋<code>glfwSetKeyCallback</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// According to source code, this make you to access successfully full extension from some latest driver without error.</span></span><br><span class="line">glewExperimental = GL_TRUE;</span><br><span class="line"><span class="comment">// Initialize GLEW to setup the OpenGL Function pointers</span></span><br><span class="line"><span class="keyword">if</span> (glewInit() != GLEW_OK)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to initialize GLEW"</span> &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>開始調用GLEW的初始化，這樣你才可以使用一些modern的function，此外如果不成功仍然會報錯，不過GLEW在剛開始還沒用到任何modern的時候，譬如本篇文章，你還不會有任何感受。對了這邊有個值得注意的是<code>glewExperimental</code>設定為<code>GL_TRUE</code>所代表的是，除了他內建定義的那些extension之外，你仍然可以使用上方提過的那個冗長語法，來取得最新的extension function，因為GLEW並不一定會更新的如此及時，所以這個打開來就是解開一些限制。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Define the viewport dimensions (if you will change the winodw size, put these in loop)</span></span><br><span class="line"><span class="keyword">int</span> width, height;</span><br><span class="line">glfwGetFramebufferSize(window, &amp;width, &amp;height);</span><br><span class="line">glViewport(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br></pre></td></tr></table></figure>
<p><code>glfwGetFramebufferSize</code>是用來取得視窗的長寬，當然寫在loop前面的意思是說，我定義的長寬並不會Resize，所以不需要放在loop中，而<code>glViewport</code>則是輸出至螢幕的設定，就是將你的畫面輸出到螢幕的時候，應該乘上多少的倍率，因為畫面輸出前都會保持長寬都是1.0的一張1.0x1.0的小圖，而輸出時的倍率與起始位置就是從(0,0)然後長為width，寬為height，然後裡面在算出倍率，之後圖片再輸出的時候就會自動從起始點然後以算出的倍率做縮放，之後顯示在視窗中，當然如果你定義的不符合你的視窗大小，就會有畫過多或過少的問題。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Looping Here until user trigger closing window event.</span></span><br><span class="line"><span class="keyword">while</span> (!glfwWindowShouldClose(window))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Clear the colorbuffer</span></span><br><span class="line">	glClearColor(<span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line">	glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">	glfwSwapBuffers(window); <span class="comment">// show on windows</span></span><br><span class="line">	glfwPollEvents(); <span class="comment">// check any event(ex. mousedown, keyup...)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>glfwWindowShouldClose</code>則是偵測視窗是否收到觸發關閉視窗事件的function，像是使用者點擊右上角的X或是按下esc之類的，而<code>glClearColor</code>代表每次清除視窗的時候要用什麼樣的顏色，這裡像是Unity一般畫面有個藍綠色一樣，或是你玩遊戲掉入虛空是黑色那樣都是這個顏色，而<code>GL_COLOR_BUFFER_BIT</code>是顯示到螢幕前的那個buffer，如果不清除就會顯示上個frame(畫面)的顏色。<code>glfwSwapBuffers</code>則是將buffer顯示到螢幕上。<code>glfwPollEvents</code>則是主動去詢問滑鼠事件或鍵盤事件之類的使用者事件，其實有另一個函式是Wait用的，不過那樣是要等你有動作才會執行，不符合一直刷新螢幕的loop<br>，所以幾乎沒人用它。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glfwDestroyWindow(window);</span><br><span class="line">glfwTerminate();</span><br></pre></td></tr></table></figure>
<p>而最後的就是glfw不使用的釋放資源方式，通常不需要特別注意這個部分，就跟init一樣，會建置就好。</p>
<p>最後的結果如下圖:<br><img src="/images/OpenGL-Beginner-Tutorial-1-Setting_Up_Enviroment/result.png" width="420"></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="環境準備">環境準備</h2><p>開始之前還是要先講一下，讀者可以選擇各種不同的 Framework 與 Library ，像是SDL,FREEGLUT,GLFW之類的，不過不管選擇哪一種，主要的OpenGL流程都是一樣的，只是有些不同的Code或Lib必須要在官方網站自行去看，本篇要講的是GLFW+GLEW在Visual Stuido 2015中的環境建置，如果不是來建置環境的讀者可以跳過本篇，或是對GLFW與GLEW有興趣再往下閱讀。</p>
<h2 id="GLFW">GLFW</h2><p><a href="http://www.glfw.org/">GLFW</a>主要是將在不同平台( Linux, Windows, Mac ) 間常用的一些使用者需求給獨立出來，這些使用者需求像是Keyboard的資訊、Mouse資訊、視窗建置….等等。將這些不同的使用者需求都統整成一個API就是其中一個GLFW在做的事，此外另一個工作是將OpenGL繪製的東西從buffer顯示到螢幕上的工作，還有一些零零總總的細節操作，最重要的是用了GLFW其實已包含OpenGL的Header，當建置好後，直接可以撰寫OpenGL的Code。</p>
<p>首先先到<a href="http://www.glfw.org/download.html">GLFW官方下載</a>中找一個名為「32-bit Windows binaries」的元件 ( 注意! 64-bit Windows binaries的建議不要使用，Dowen我在建置的時候會遇到非常多問題)，抓下來後接下來就照著以下的圖片設置。</p>
<p>將GLFW放到任何認為合適的地方，之後再點選VS的專案-&gt;屬性，再點選VC++目錄，然後我們主要要變動的有以下兩個，Include目錄與程式庫目錄。<br><img src="/images/OpenGL-Beginner-Tutorial-1-Setting_Up_Enviroment/VSProperty.png" width="600"><br>設定好Include與Library。<br>]]>
    
    </summary>
    
      <category term="GLEW" scheme="http://tokenyet.github.io/tags/GLEW/"/>
    
      <category term="GLFW" scheme="http://tokenyet.github.io/tags/GLFW/"/>
    
      <category term="OpenGL" scheme="http://tokenyet.github.io/tags/OpenGL/"/>
    
      <category term="OpenGL Tutorial" scheme="http://tokenyet.github.io/tags/OpenGL-Tutorial/"/>
    
      <category term="OpenGL入門教學" scheme="http://tokenyet.github.io/tags/OpenGL%E5%85%A5%E9%96%80%E6%95%99%E5%AD%B8/"/>
    
      <category term="OpenGL安裝" scheme="http://tokenyet.github.io/tags/OpenGL%E5%AE%89%E8%A3%9D/"/>
    
      <category term="OpenGL教學" scheme="http://tokenyet.github.io/tags/OpenGL%E6%95%99%E5%AD%B8/"/>
    
      <category term="Visual Studio" scheme="http://tokenyet.github.io/tags/Visual-Studio/"/>
    
      <category term="OpenGL" scheme="http://tokenyet.github.io/categories/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenGL 藍寶入門教學 0: Introduce]]></title>
    <link href="http://tokenyet.github.io/2016/06/28/OpenGL-Beginner-Tutorial-0-Introduce/"/>
    <id>http://tokenyet.github.io/2016/06/28/OpenGL-Beginner-Tutorial-0-Introduce/</id>
    <published>2016-06-28T13:36:47.000Z</published>
    <updated>2016-08-25T08:26:55.522Z</updated>
    <content type="html"><![CDATA[<h2 id="前言:">前言:</h2><p>不管開始任何事情之前，必須先對要做的事情先有個了解才能開始，學習OpenGL也不例外。開始前，先說一下我做教學文的風格，由於這是我以一個學中教，教中學的角度來製作，所以可能會有些不精確，希望哪裡有錯誤可以幫忙改正或指教，謝謝。</p>
<h2 id="簡介:">簡介:</h2><p>首先OpenGL(Graphics Library)是一個API，也就是說他是一個幫助我們在不同的顯示卡配備之間做一個橋樑。聽起來很籠統，更詳細又簡單的說，即是說每張顯示卡在製作的時候，都有不同數量的繪圖處理器與不同晶片(ex.GTX970 1080)。而你不必擔心到底要如何針對不同顯示卡的規格(Spec)而寫那些控制不同機器的語法就是OpenGL的工作。</p>
<h2 id="歷史:">歷史:</h2><p>而身為一個OpenGL的使用者也需要知曉一點他的過去與未來，過去OpenGL是源自Silicon Graphics這家公司，當時這家公司專門製作繪圖電腦，又貴又大而且寫繪圖語言的時候，不同的繪圖電腦會有不同的寫法，完全沒有一個統一的規範。經過了一段時間，終於想到解法，就是將針對系統部分的程式碼拿掉後，也就是拿掉只能在規格完全符合才可操作API的部分，之後就開發了OpenGL 1.0版本。這個歷史告訴我們，找出邏輯中相同與不同的部分獨立出來，可以增進事務的美好。</p>
<img src="/images/OpenGL-Beginner-Tutorial-0-Introduce/OpenGL_API.jpg" width="420">
<a id="more"></a>
<h2 id="Core-Profile:_(核心模型)">Core-Profile: (核心模型)</h2><p>簡單講完他的歷史與定位後，有一件關於OpenGL核心的事情需要先說，就是在OpenGL 3.0 (2008年)後，分為兩個核心模型，一個稱為Modern版，一個稱為Compatible版。一如字面意思Modern就是現代版本，多了很多Shader,Depth,Stencil,Geometry…的一些新功能，而Compatible就是繼續使用舊的管線(fixed-pipeline)，很難讓使用者客製化。至於為什麼會講核心模型，剛開始就會要使用者講明要使用的哪種核心，才能繼續寫下去，如果說你定義要現代版，但是顯示卡不支援就會馬上知道問題所在。</p>
<img src="/images/OpenGL-Beginner-Tutorial-0-Introduce/OpenGL_Detect.jpg" width="420">
<h2 id="Pipelines,_Primitives,_Pixels:_(管線,_繪圖元素,_像素)">Pipelines, Primitives, Pixels: (管線, 繪圖元素, 像素)</h2><p>整個OpenGL大致上的管線的內容分為fixed與shader兩部分，fixed的部分就是我們不可參與程式的部分，而shader的部分是可以加入程式碼深度進行修改的部分。這裡簡單解釋shader，想像這一個shader就是一個超級小的筆刷，然後這個筆刷可以根據螢幕上每一點進行不同的繪製，而為何可以進行不同的繪製呢?因為這個shader就是你可以寫程式的部分，這個一般解釋是著色器，聽起來很難想像的名詞，不知道經過我有點糟的比喻有沒有想像一點。<br>(哦對，這裡的fixed不是指古早OpenGL，而是說流程中有部分是固定不可參與的)</p>
<p>OpenGL在繪製任何你所指定的東西的時候，都是將它拆解成或千或萬個Primitives之後，才開始進行繪製。而繪圖元素主要有三個，一個是點(point)，到真正實作的時候，你會發現在三維空間中要繪製一個三角形的時候，一定會指派三個點，然後點就是只畫點。另一個是線(line)，只描繪你指定點間的線。還有三角形(triangle)，就是將你指定的點間的像素都畫出來。而介紹繪圖元素的意義就是，當你要畫任何的形狀，臉阿、車子阿、多邊形怪物阿、什麼的都拆成這三個基本繪圖元素，這樣顯示卡只要專心對三角形的繪圖演算法做處理就好了，至於為什麼是三角形除了本身顯卡就只對三角形優化過外，就是Convex(凸邊形)的演算法比Concave(凹邊形)的容易許多。</p>
<p>其實剛剛講了很多，並不是真正的繪製，只是屬於形狀的分割最佳化，到後面經過你一連串的shader與一些fixed後最終才會經過一個名為rasterizer的傢伙進行著色(真正開始動像素的地方)，中文叫光柵化，簡單想像就是一個幫你將3D的東西繪製到2D上的步驟。</p>
<h2 id="Extension">Extension</h2><p>這個算是新版OpenGL的一個利於內部人員的極佳擴充機制，而這些擴充機制雖然利用開發人員，不過當我們想要使用的時候卻是長得像下面這般模樣。<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const char <span class="built_in">*</span>name = <span class="string">"glGenBuffers"</span>;</span><br><span class="line">void <span class="built_in">*</span>p = <span class="params">(void *)</span>wglGetProcAddress<span class="params">(name)</span>;</span><br><span class="line"><span class="keyword">if</span><span class="params">(p == <span class="number">0</span> ||</span><br><span class="line"><span class="params">(p == <span class="params">(void*)</span><span class="number">0</span>x1)</span> || <span class="params">(p == <span class="params">(void*)</span><span class="number">0</span>x2)</span> || <span class="params">(p == <span class="params">(void*)</span><span class="number">0</span>x3)</span> ||</span><br><span class="line"><span class="params">(p == <span class="params">(void*)</span>-<span class="number">1</span>)</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">	HMODULE <span class="function"><span class="keyword">module</span> =</span> LoadLibraryA<span class="params">(<span class="string">"opengl32.dll"</span>)</span>;</span><br><span class="line">	p = <span class="params">(void *)</span>GetProcAddress<span class="params">(module, name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>寫了8行Code只為了取得一個function在顯示卡內部的哪個位置，然後拿出來提供我們使用，看到這裡不需要害怕，<a href="/2016/07/05/OpenGL-Beginner-Tutorial-1-Setting_Up_Enviroment">下篇</a>文章會提到如何使用第三發開發的framework幫助我們解決這些問題。</p>
<h2 id="小結:">小結:</h2><p>如果聽不懂管線或是對pipelines感到陌生，就當作是一個產品生產的流程圖，先做好車體結構-&gt;再安裝車殼-&gt;再安裝輪胎，這樣的一個流程稱為pipeline。<br>其實本來多弄點圖解，不過實在是有點累(懶)呀，如果有需要的話，我再努力做給大家看。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言:">前言:</h2><p>不管開始任何事情之前，必須先對要做的事情先有個了解才能開始，學習OpenGL也不例外。開始前，先說一下我做教學文的風格，由於這是我以一個學中教，教中學的角度來製作，所以可能會有些不精確，希望哪裡有錯誤可以幫忙改正或指教，謝謝。</p>
<h2 id="簡介:">簡介:</h2><p>首先OpenGL(Graphics Library)是一個API，也就是說他是一個幫助我們在不同的顯示卡配備之間做一個橋樑。聽起來很籠統，更詳細又簡單的說，即是說每張顯示卡在製作的時候，都有不同數量的繪圖處理器與不同晶片(ex.GTX970 1080)。而你不必擔心到底要如何針對不同顯示卡的規格(Spec)而寫那些控制不同機器的語法就是OpenGL的工作。</p>
<h2 id="歷史:">歷史:</h2><p>而身為一個OpenGL的使用者也需要知曉一點他的過去與未來，過去OpenGL是源自Silicon Graphics這家公司，當時這家公司專門製作繪圖電腦，又貴又大而且寫繪圖語言的時候，不同的繪圖電腦會有不同的寫法，完全沒有一個統一的規範。經過了一段時間，終於想到解法，就是將針對系統部分的程式碼拿掉後，也就是拿掉只能在規格完全符合才可操作API的部分，之後就開發了OpenGL 1.0版本。這個歷史告訴我們，找出邏輯中相同與不同的部分獨立出來，可以增進事務的美好。</p>
<img src="/images/OpenGL-Beginner-Tutorial-0-Introduce/OpenGL_API.jpg" width="420">]]>
    
    </summary>
    
      <category term="OpenGL" scheme="http://tokenyet.github.io/tags/OpenGL/"/>
    
      <category term="OpenGL Extension" scheme="http://tokenyet.github.io/tags/OpenGL-Extension/"/>
    
      <category term="OpenGL Tutorial" scheme="http://tokenyet.github.io/tags/OpenGL-Tutorial/"/>
    
      <category term="OpenGL intro" scheme="http://tokenyet.github.io/tags/OpenGL-intro/"/>
    
      <category term="OpenGL入門教學" scheme="http://tokenyet.github.io/tags/OpenGL%E5%85%A5%E9%96%80%E6%95%99%E5%AD%B8/"/>
    
      <category term="OpenGL教學" scheme="http://tokenyet.github.io/tags/OpenGL%E6%95%99%E5%AD%B8/"/>
    
      <category term="OpenGL" scheme="http://tokenyet.github.io/categories/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Windows10-音量控制問題]]></title>
    <link href="http://tokenyet.github.io/2015/10/08/Windows10-%E9%9F%B3%E9%87%8F%E6%8E%A7%E5%88%B6%E5%95%8F%E9%A1%8C/"/>
    <id>http://tokenyet.github.io/2015/10/08/Windows10-音量控制問題/</id>
    <published>2015-10-08T11:26:20.000Z</published>
    <updated>2015-10-08T11:51:46.471Z</updated>
    <content type="html"><![CDATA[<p>前言:<br>Windows 10問題連連，假設你跟Dowen一樣想玩踩地雷，但是從Windows App載完後發現音量超級大聲，且假設說你喜歡聽自己的音樂，又想聽Windows App的特效的時候，就會發現「什麼?<strong>不能調音量!!</strong>」，因為Win10在Modern UI的這些Metro App中沒有加入適當API，所以在音量混合器中沒有這個選項。<br>因此，繼透明度、Classic Shell…等，為Win10裝插件之旅又開始了。</p>
<p>正題開始:<br>到<a href="https://github.com/File-New-Project/EarTrumpet/releases" target="_blank" rel="external">EarTrumpet</a>的Release中下載最新版本。<br>如果無法安裝，顯示<strong>This program does not support the version of Windows your computer is running</strong>。<br>則以下這部分就必須依賴有Visual Studio的人，載下Source Code後，自行編譯出來的.EXE跟.DLL放到一個固定位置。<br>將.EXE的捷徑放到啟動中，這樣以後就能隨時開機就自動開啟這個軟體了。<br>這軟體大勝Windows內建的Mixer啊!!!</p>
<p>如果有人有需求，我在附上自己編譯出來的檔案以供使用。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前言:<br>Windows 10問題連連，假設你跟Dowen一樣想玩踩地雷，但是從Windows App載完後發現音量超級大聲，且假設說你喜歡聽自己的音樂，又想聽Windows App的特效的時候，就會發現「什麼?<strong>不能調音量!!</strong>」，因為W]]>
    </summary>
    
      <category term="Metro App" scheme="http://tokenyet.github.io/tags/Metro-App/"/>
    
      <category term="Modern UI" scheme="http://tokenyet.github.io/tags/Modern-UI/"/>
    
      <category term="Win10" scheme="http://tokenyet.github.io/tags/Win10/"/>
    
      <category term="Windows Store" scheme="http://tokenyet.github.io/tags/Windows-Store/"/>
    
      <category term="Windows10" scheme="http://tokenyet.github.io/tags/Windows10/"/>
    
      <category term="音量" scheme="http://tokenyet.github.io/tags/%E9%9F%B3%E9%87%8F/"/>
    
      <category term="Windows" scheme="http://tokenyet.github.io/categories/Windows/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenCV例外狀況]]></title>
    <link href="http://tokenyet.github.io/2015/10/08/OpenCV%E4%BE%8B%E5%A4%96%E7%8B%80%E6%B3%81/"/>
    <id>http://tokenyet.github.io/2015/10/08/OpenCV例外狀況/</id>
    <published>2015-10-08T05:12:51.000Z</published>
    <updated>2015-10-08T11:23:50.316Z</updated>
    <content type="html"><![CDATA[<p>前言:<br>在使用EmguCV的時候，常常在自己的電腦可以，換到其他人電腦的環境後，就萬事皆悲。<br>而在這裡，Dowen寫下幾種解法供大家參考。這裡以EmguCv為例。</p>
<h1 id="針對_TypeInitializer_Exception_錯誤">針對 TypeInitializer Exception 錯誤</h1><p>解法1. 查看自己的環境設定是否有設定好<br>沒事的話環境PATH的地方建議設定x86即可<br>然後再試試看能不能執行。</p>
<p>解法2. 在Visual Studio加入參考的地方加入 <code>cvextern.dll, Emgu.CV.dll, Emgu.CV.UI.dll, Emgu.Util.dll</code><br>然後再執行看看是否能運行。<br>建議測試的時候可以加入指令測試。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using Emgu.CV;&#10;using Emgu.CV.Structure;&#10;&#10;Image&#60;Bgra,Byte&#62; test = new Image&#60;Bgra,Byte&#62;(1,1);</span><br></pre></td></tr></table></figure>
<p>解法3. 如果最後還是搞不定請將 <code>emgucv-windows-universal 2.4.10.1940\bin\x86</code>下所有檔案<br>複製到你專案底下的 <code>Debug\bin\</code> 裡面(執行檔.EXE的旁邊)。</p>
<p>總結一下，解法3應該是最後的方法，因為如果將Dll丟進專案內會導致環境變大。<br>對了，為什麼只有針對 TypeInitializer Exception 呢?因為目前還沒遇到其他例外。<br>如往後有遇到在補上囉。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前言:<br>在使用EmguCV的時候，常常在自己的電腦可以，換到其他人電腦的環境後，就萬事皆悲。<br>而在這裡，Dowen寫下幾種解法供大家參考。這裡以EmguCv為例。</p>
<h1 id="針對_TypeInitializer_Exception_錯誤">針對 T]]>
    </summary>
    
      <category term="EmguCV" scheme="http://tokenyet.github.io/tags/EmguCV/"/>
    
      <category term="Exception" scheme="http://tokenyet.github.io/tags/Exception/"/>
    
      <category term="OpenCV" scheme="http://tokenyet.github.io/tags/OpenCV/"/>
    
      <category term="Visual Studio" scheme="http://tokenyet.github.io/tags/Visual-Studio/"/>
    
      <category term="OpenCV" scheme="http://tokenyet.github.io/categories/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Windows10 桌面圖示排列失效]]></title>
    <link href="http://tokenyet.github.io/2015/09/27/Windows10-%E6%A1%8C%E9%9D%A2%E5%9C%96%E7%A4%BA%E6%8E%92%E5%88%97%E5%A4%B1%E6%95%88/"/>
    <id>http://tokenyet.github.io/2015/09/27/Windows10-桌面圖示排列失效/</id>
    <published>2015-09-27T04:47:19.000Z</published>
    <updated>2015-09-27T05:11:31.049Z</updated>
    <content type="html"><![CDATA[<p>升上Win10沒多久後發現桌面圖示無法像以前一樣排列到想要的位置。<br>每次開機就會回到左方自動排列，右鍵重新整理也是如此。</p>
<p>經由ESET論壇的發布，<br>升級上Windwos10後，剛好又是ESET的人才會發生的問題。<br>接下來說明如何解決這問題。<br>(引用自ESET forums:AREZCO)</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HKEY_CLASSES_ROOT<span class="command">\Wow</span>6432Node<span class="command">\CLSID</span><span class="command">\&#123;</span>42aedc87-2188-41fd-b9a3-0c966feabec1<span class="special">&#125;</span><span class="command">\InProcServer</span>32<span class="command">\</span><br><span class="line"></span>HKEY_CLASSES_ROOT<span class="command">\CLSID</span><span class="command">\&#123;</span>42aedc87-2188-41fd-b9a3-0c966feabec1<span class="special">&#125;</span><span class="command">\InProcServer</span>32\</span><br></pre></td></tr></table></figure>
<p>對於這兩個檔案<br>選取 預設(Default) 將值從 <code>%SystemRoot%\SysWow64\shell32.dll</code> 取代為 <code>%SystemRoot%\system32\windows.storage.dll</code>.</p>
<p>但你可能會發生權限不夠的問題。<br>這時候在做上述動作之前，必須先取得權限。<br>對<code>InProcServer32</code>右鍵按<code>使用權限</code> (Use Permission)，之後選<code>進階</code> (Advanced)，<br>在上方<code>擁有者</code> (Owner)的位置點選<code>變更</code>，之後繼續點選<code>進階</code> (Advanced)，<br>再來點選<code>立即選找</code> (Find Now) 選擇<code>Administrators</code>後，按下確定。<br>之後回到剛剛看到擁有者點選變更的視窗中，勾選以下:<br><code>取代子容器與物件的擁有者</code> (Replace owner on subcontainers and objects)<br><code>以可從此物件繼承的權限項目取代所有子物件的權限項目</code> (Replace all child object permission entries…)<br>最後回到一開始使用權限的視窗，選擇Administrator並勾選<code>完全控制</code> (Full Control)<br>就取得該註冊資料夾的權限。</p>
<p>完成後，<code>重開電腦</code> (Reboot)應該就可以得到改善。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>升上Win10沒多久後發現桌面圖示無法像以前一樣排列到想要的位置。<br>每次開機就會回到左方自動排列，右鍵重新整理也是如此。</p>
<p>經由ESET論壇的發布，<br>升級上Windwos10後，剛好又是ESET的人才會發生的問題。<br>接下來說明如何解決這問題。<]]>
    </summary>
    
      <category term="Win10" scheme="http://tokenyet.github.io/tags/Win10/"/>
    
      <category term="Windows10" scheme="http://tokenyet.github.io/tags/Windows10/"/>
    
      <category term="排列失效" scheme="http://tokenyet.github.io/tags/%E6%8E%92%E5%88%97%E5%A4%B1%E6%95%88/"/>
    
      <category term="桌面圖示" scheme="http://tokenyet.github.io/tags/%E6%A1%8C%E9%9D%A2%E5%9C%96%E7%A4%BA/"/>
    
      <category term="重新整理" scheme="http://tokenyet.github.io/tags/%E9%87%8D%E6%96%B0%E6%95%B4%E7%90%86/"/>
    
      <category term="Windows" scheme="http://tokenyet.github.io/categories/Windows/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Windows10 System記憶體占用]]></title>
    <link href="http://tokenyet.github.io/2015/09/25/Windows10-System%E8%A8%98%E6%86%B6%E9%AB%94%E5%8D%A0%E7%94%A8/"/>
    <id>http://tokenyet.github.io/2015/09/25/Windows10-System記憶體占用/</id>
    <published>2015-09-25T08:17:23.000Z</published>
    <updated>2015-09-25T09:52:32.004Z</updated>
    <content type="html"><![CDATA[<p>前言:<br>升級到Windows10之後，真的是一堆BUGGG阿。<br>認識的人升級到10都跟我說沒什麼問題，只能說相信別人不如自己實測阿。<br>還有輸入法這糟糕的設置，根本只設計給英文使用者嘛。<br>大部分升級的人都說「習慣就好」，我真的很不喜歡這句話。<br>聽過UX嗎?習慣這句話根本就不是UX而是斗M。<br>如果是因為更值得的功能而改變習慣，那在UX上的確有其道理。<br>但是Win8後的輸入法又沒什麼特別的取代性，改了習慣壞了體驗，唉。</p>
<p>正題:<br>最近開始用VS2013有用到WinAPI，然後用了一段時間後，突然電腦趨近於當機???!!<br>當時我電腦上有Opera，Chrome，Planetside 2，Steam，Line，Telegram，ESET…。<br>然後以為是WinAPI的問題。<br>但是研究後發現是 <font color="red">System (ntoskrnl.exe)</font> 在搞鬼，這東西在Win10上可說是臭名昭彰，還有人藍白當機。</p>
<p>經由網路上一系列的解法我都嘗試過了，<br>第一個是Regedit<br>在HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\Ndu路徑下<br>將 <font color="red">Start</font> 的值從 <font color="red">2</font> 改為 <font color="red">4</font><br>(個人這方法無效)</p>
<p>第二個是設定(Win10我不解的奇怪新產物)<br>點桌面-&gt;個人化-&gt;設定-&gt;系統-&gt;通知與動作<br>將 <font color="red">顯示關於Windows的通知</font> 關掉!!!<br>(這方法也沒什麼效果..)</p>
<p>第三個是關閉Superfetch與Prefetch(沒效也可以減少SSD的操勞)<br>Win+R -&gt; services.msc -&gt; Superfetch disable掉<br>到HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Memory Management\PrefetchParameters<br>把EnablePrefetcher與EnableSuperfetch改為0</p>
<p>建議可以三個方法都嘗試，如果只嘗試一個無效的話。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前言:<br>升級到Windows10之後，真的是一堆BUGGG阿。<br>認識的人升級到10都跟我說沒什麼問題，只能說相信別人不如自己實測阿。<br>還有輸入法這糟糕的設置，根本只設計給英文使用者嘛。<br>大部分升級的人都說「習慣就好」，我真的很不喜歡這句話。<br>聽]]>
    </summary>
    
      <category term="System" scheme="http://tokenyet.github.io/tags/System/"/>
    
      <category term="Win10" scheme="http://tokenyet.github.io/tags/Win10/"/>
    
      <category term="Windows10" scheme="http://tokenyet.github.io/tags/Windows10/"/>
    
      <category term="ntoskrnl.exe" scheme="http://tokenyet.github.io/tags/ntoskrnl-exe/"/>
    
      <category term="Windows" scheme="http://tokenyet.github.io/categories/Windows/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Windows10 升級相關問題]]></title>
    <link href="http://tokenyet.github.io/2015/09/19/Windows10-%E5%8D%87%E7%B4%9A%E7%9B%B8%E9%97%9C%E5%95%8F%E9%A1%8C/"/>
    <id>http://tokenyet.github.io/2015/09/19/Windows10-升級相關問題/</id>
    <published>2015-09-18T18:43:56.000Z</published>
    <updated>2015-09-25T08:49:46.165Z</updated>
    <content type="html"><![CDATA[<p>第一次進行Windows系列的升級，就遇到了很多問題，為了拯救跟我有相同困擾的人，所以趕緊來發一篇文。</p>
<hr>

<h2 id="安裝前">安裝前</h2><hr>

<p>遇到的問題之一<br>首先<strong>直接點Windows10圖示</strong>的時候到85%就停住了。 所以通過圖示升級失敗。<br>再來遇到的問題是把<strong>Win10燒到光碟</strong>後想要通過<strong>重開機</strong>的boot模式來進行更新，<br>遇到了要不要移除媒體的奇怪問題，把搖桿跟一些東西移除後，仍不行。</p>
<font color="gray"><em>這裡順便說一下，有些主機板會因為插了某些3c產品在usb上而導致無法開機，<br>像是Dowen我插入了mp3在usb上之後，就卡在boot畫面無法開機。</em></font>


<p>再來，用光碟直接在Windows中點選光碟機進行安裝，<br>安裝過程一開始很順利，但是到了真正要安裝的時候卡在0%然後馬上安裝失敗。<br><strong>0%的解決辦法是 解除安裝防毒軟體</strong><br>之後又遇到了18%安裝失敗<br><strong>18%的解決辦法是 點選$Windows.~BT這個資料夾然後把 <em>唯讀</em> 屬性取消掉</strong><br>18%之後的如果有遇到問題通常就是照著解除唯讀去做，因為你解除了一瞬間，<br>下一個tempo又被系統改回唯讀，我想這是win10升級的一個bug…。<br>在過了18%大關後，只要等待到最後就可以了。</p>
<hr>

<h2 id="安裝後">安裝後</h2><hr>

<p>第一個遇到的問題就是<em>點任何檔案都無法回應</em><br>然後在觀察錯誤訊息後，發現新酷音(非TSF版)的ChewingServer.exe作祟。<br>先切換輸入法後，發現一切都正常，然後去控制台把新酷音解安裝了!!</p>
<p>在來就不是問題，而是使用習慣，自己摸索一些東西後，發現有一些東西要額外安裝。</p>
<p><strong>像是視窗的玻璃特效，必須去上網找<a href="http://pan.baidu.com/s/1c50zc" target="_blank" rel="external">AeroGlass 10240</a></strong></p>
<p><strong>像是用不習慣一些介面就可以用<a href="http://www.classicshell.net/" target="_blank" rel="external">Classic Shell</a>傳統介面軟體幫你改回來</strong><br>(像點開始時，那兩塊panel)</p>
<p><strong>像是開始列的透明化調整，可以用<a href="http://chime.tv/products/glass2k.shtml" target="_blank" rel="external">Glass2k</a></strong><br>(ps.這個透明連icon也被透明化，所以使用自行斟酌)</p>
<hr>

<p>剩下未解決的問題:<br>還有一些比較不習慣的問題，<br>像是輸入法在很多editor上，打字會跑在整個螢幕的左上角。<br>像是開始列右邊的icon有關於系統的都無法移動位置，只能關閉。<br>像是桌面的設定，因為是新風格，不習慣想改回win7連結控制台的那種模式。<br>像是folder開起來後上面跟以前不同。<br>像是開始列的透明度無法自行更改，有點失望。</p>
<p>win10目前給我的感覺<br>少了一些常用的介面設置，<br>很多軟體的支援度還不夠，<br>拿掉了很多我喜歡的酷炫特效，<br>點開始跳出來的兩大Panel讓我有點不知道看哪，<br>最後的最後輸入法變成win+space也需要適應一番。</p>
<p>如果有什麼功能忽略沒寫到，歡迎通知我!</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>第一次進行Windows系列的升級，就遇到了很多問題，為了拯救跟我有相同困擾的人，所以趕緊來發一篇文。</p>
<hr>

<h2 id="安裝前">安裝前</h2><hr>

<p>遇到的問題之一<br>首先<strong>直接點Windows10圖示</strong>的]]>
    </summary>
    
      <category term="Win10" scheme="http://tokenyet.github.io/tags/Win10/"/>
    
      <category term="Win7" scheme="http://tokenyet.github.io/tags/Win7/"/>
    
      <category term="Windows10" scheme="http://tokenyet.github.io/tags/Windows10/"/>
    
      <category term="Windows7" scheme="http://tokenyet.github.io/tags/Windows7/"/>
    
      <category term="升級" scheme="http://tokenyet.github.io/tags/%E5%8D%87%E7%B4%9A/"/>
    
      <category term="Windows" scheme="http://tokenyet.github.io/categories/Windows/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Interpolation筆記]]></title>
    <link href="http://tokenyet.github.io/2015/09/06/Interpolation%E7%AD%86%E8%A8%98/"/>
    <id>http://tokenyet.github.io/2015/09/06/Interpolation筆記/</id>
    <published>2015-09-06T06:52:48.000Z</published>
    <updated>2015-09-06T07:41:25.271Z</updated>
    <content type="html"><![CDATA[<p><hr></p>
<h3 id="證明筆記,如有空再補上說明">證明筆記,如有空再補上說明</h3><p><hr><br><strong>1. 線性內插(Linear Interpolation)</strong></p>
<p>$ y = ax + b , f(x) = ax + b $ </p>
<p>$ y_i = a x_i + b $</p>
<p>$ y_{i+1} = a x_{i+1} + b $</p>
<p>$ y_{i+1} - y_i = a_{i+1} -a x_i $</p>
<p>$ y_{i+1} - y_i = a (x_{i+1} -a x_i) $</p>
<p>$ y_{i+1} - y_i/(x_{i+1} -x_i) = a $</p>
<p>$ y_i = (y_{i+1} - y_i/(x_{i+1} -x_i))x_i + b $</p>
<p>$ y_i - ax_i = b $</p>
<p>$ f(x) = (y_{i+1} - yi/(x_{i+1} -x_i))x + yi -ax_i $</p>
<p>$ f(x) = (y_{i+1} - yi/(x_{i+1} -xi))(x-xi) + yi $</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><hr></p>
<h3 id="證明筆記,如有空再補上說明">證明筆記,如有空再補上說明</h3><p><hr><br><strong>1. 線性內插(Linear Interpolation)</strong></p>
<p>$ y = ax + b , f(x) = ]]>
    </summary>
    
      <category term="Interpolation" scheme="http://tokenyet.github.io/tags/Interpolation/"/>
    
      <category term="內插" scheme="http://tokenyet.github.io/tags/%E5%85%A7%E6%8F%92/"/>
    
      <category term="線性代數" scheme="http://tokenyet.github.io/tags/%E7%B7%9A%E6%80%A7%E4%BB%A3%E6%95%B8/"/>
    
      <category term="數學筆記" scheme="http://tokenyet.github.io/categories/%E6%95%B8%E5%AD%B8%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[QT中安裝OpenGL教學]]></title>
    <link href="http://tokenyet.github.io/2015/08/26/QT%E4%B8%AD%E5%AE%89%E8%A3%9DOpenGL%E6%95%99%E5%AD%B8/"/>
    <id>http://tokenyet.github.io/2015/08/26/QT中安裝OpenGL教學/</id>
    <published>2015-08-26T09:40:26.000Z</published>
    <updated>2015-09-26T11:39:47.944Z</updated>
    <content type="html"><![CDATA[<p>This is a tutorial for install glew &amp; glfw on ubuntu with qt.</p>
<p>Enviroment : Ubuntu14 + QT5</p>
<h2 id="Install_glfw">Install glfw</h2><ol>
<li>First. we need to install dependencies on ubuntu</li>
</ol>
<figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install xorg-<span class="built_in">dev</span></span><br><span class="line">sudo apt-<span class="built_in">get</span> install libglu1-mesa-<span class="built_in">dev</span></span><br></pre></td></tr></table></figure>
<h2 id="Install_glew">Install glew</h2><ol>
<li><p>Then download source package at <a href="http://glew.sourceforge.net/" target="_blank" rel="external">official</a></p>
</li>
<li><p>Extract your package and open your terminal, then cd to what your package location which you just extracted.</p>
</li>
<li><p>Do following commnad to install</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span> extension</span><br><span class="line"><span class="built_in">make</span> </span><br><span class="line">sudo <span class="built_in">make</span> install</span><br><span class="line">sudo <span class="built_in">make</span> clean</span><br></pre></td></tr></table></figure>
<h2 id="Open_QT_project_and_set_opengl_settings">Open QT project and set opengl settings</h2><ol>
<li><p>Open a console project in QT</p>
</li>
<li><p>Add following settings in your .pro file anywhere.</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LIBS +=<span class="operator">-l</span>GLEW -lglfw3 <span class="operator">-l</span>GL <span class="operator">-l</span>X11 <span class="operator">-l</span>Xi <span class="operator">-l</span>Xrandr <span class="operator">-l</span>Xxf86vm <span class="operator">-l</span>Xinerama <span class="operator">-l</span>Xcursor -lrt -lm -pthread</span><br></pre></td></tr></table></figure>
<p>Try a simple test.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> GLEW_STATIC</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;GL/glew.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;GLFW/glfw3.h&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    glfwInit();</span><br><span class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line">    glfwWindowHint(GLFW_RESIZABLE, GL_FALSE);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Enjoy_it">Enjoy it</h2>]]></content>
    <summary type="html">
    <![CDATA[<p>This is a tutorial for install glew &amp; glfw on ubuntu with qt.</p>
<p>Enviroment : Ubuntu14 + QT5</p>
<h2 id="Install_glfw">Install gl]]>
    </summary>
    
      <category term="OpenGL" scheme="http://tokenyet.github.io/tags/OpenGL/"/>
    
      <category term="QT" scheme="http://tokenyet.github.io/tags/QT/"/>
    
      <category term="Ubuntu" scheme="http://tokenyet.github.io/tags/Ubuntu/"/>
    
      <category term="OpenGL" scheme="http://tokenyet.github.io/categories/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[線性代數-座標轉換筆記]]></title>
    <link href="http://tokenyet.github.io/2015/08/19/%E5%BA%A7%E6%A8%99%E8%BD%89%E6%8F%9B%E7%AD%86%E8%A8%98/"/>
    <id>http://tokenyet.github.io/2015/08/19/座標轉換筆記/</id>
    <published>2015-08-19T13:08:52.000Z</published>
    <updated>2016-08-11T14:45:01.340Z</updated>
    <content type="html"><![CDATA[<ol>
<li>旋轉證明</li>
</ol>
<p><a title="View with the Desmos Graphing Calculator" href="https://www.desmos.com/calculator/p2xvjukzd7" target="_blank" rel="external">  <img src="https://s3.amazonaws.com/calc_thumbs/production/p2xvjukzd7.png" width="200px" height="200px" style="border:1px solid #ccc; border-radius:5px"></a></p>
<p>假設紅線端點座標為 $ (x1,y1) $<br>假設藍線端點座標為 $ (x,y) $<br>紅線與藍線之夾角為 $ \theta $<br>籃線與 $X$ 軸之夾角為 $ a $<br>長度為 $ r $<br>則得到<br>$ x1 = x \cos \theta - y \sin \theta $<br>$ y1 = x \sin \theta + y \cos \theta $<br>證明如下:</p>
<p>經由畢氏定理得知:<br>$ x = r \cos a $<br>$ y = r \sin a $</p>
<p>$ x1 = r \cos (\theta + a) = r \cos \theta \cos a - r \sin \theta \sin a $<br>$ y1 = r \sin (\theta + a) = r \sin \theta \cos a + r \sin a \cos \theta $</p>
<p>$ x1 = r \cos \theta \cos a - r \sin \theta \sin a = x \cos \theta - y \sin \theta $<br>$ y1 = r \sin \theta \cos a + r \sin a \cos \theta = x \sin \theta + y \cos \theta $</p>
<p>備註:<br>$ r \cos a = x $<br>$ r \sin a = y $</p>
<p>因此得證:<br>$ x1 = x \cos \theta - y \sin \theta $<br>$ y1 = x \sin \theta + y \cos \theta $</p>
]]></content>
    <summary type="html">
    <![CDATA[<ol>
<li>旋轉證明</li>
</ol>
<p><a title="View with the Desmos Graphing Calculator" href="https://www.desmos.com/calculator/p2xvjukzd7" target="]]>
    </summary>
    
      <category term="座標轉換" scheme="http://tokenyet.github.io/tags/%E5%BA%A7%E6%A8%99%E8%BD%89%E6%8F%9B/"/>
    
      <category term="線性代數" scheme="http://tokenyet.github.io/tags/%E7%B7%9A%E6%80%A7%E4%BB%A3%E6%95%B8/"/>
    
      <category term="數學筆記" scheme="http://tokenyet.github.io/categories/%E6%95%B8%E5%AD%B8%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Ubuntu Tracker-Store問題]]></title>
    <link href="http://tokenyet.github.io/2015/08/17/Ubuntu%20Tracker-Store%E5%95%8F%E9%A1%8C/"/>
    <id>http://tokenyet.github.io/2015/08/17/Ubuntu Tracker-Store問題/</id>
    <published>2015-08-17T03:28:14.000Z</published>
    <updated>2015-08-19T12:46:27.956Z</updated>
    <content type="html"><![CDATA[<p>在升級到14版後<br>安裝了Gnome一段時間又灌了零零總總的東西之後…</p>
<p>有一次右鍵-&gt;檔案-&gt;屬性的時候<br>竟然桌面當了!? 有關於檔案系統的任何東西都開不起來。</p>
<p>在使用System monitor觀察後，發現是tracker-store在做怪<br>是安裝gnome之後自動開啟建立索引的程式</p>
<p>但由於在本系統中已經成為多餘的障礙，所以決定把他拿掉。<br>上網找東找西之後，其實只有一句話就解決問題了！<br>到終端機輸入<br><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tracker-<span class="keyword">control</span> -r</span><br></pre></td></tr></table></figure></p>
<h2 id="解決_!">解決 !</h2>]]></content>
    <summary type="html">
    <![CDATA[<p>在升級到14版後<br>安裝了Gnome一段時間又灌了零零總總的東西之後…</p>
<p>有一次右鍵-&gt;檔案-&gt;屬性的時候<br>竟然桌面當了!? 有關於檔案系統的任何東西都開不起來。</p>
<p>在使用System monitor觀察後，發現是tracker]]>
    </summary>
    
      <category term="Ubuntu" scheme="http://tokenyet.github.io/tags/Ubuntu/"/>
    
      <category term="Ubuntu property" scheme="http://tokenyet.github.io/tags/Ubuntu-property/"/>
    
      <category term="tracker-store" scheme="http://tokenyet.github.io/tags/tracker-store/"/>
    
      <category term="Linux" scheme="http://tokenyet.github.io/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在Ubuntu上系統架設VirtualBox]]></title>
    <link href="http://tokenyet.github.io/2015/07/17/%E5%9C%A8Ubuntu%E4%B8%8A%E7%B3%BB%E7%B5%B1%E6%9E%B6%E8%A8%ADVirtualBox/"/>
    <id>http://tokenyet.github.io/2015/07/17/在Ubuntu上系統架設VirtualBox/</id>
    <published>2015-07-17T09:52:26.000Z</published>
    <updated>2015-08-19T12:46:27.957Z</updated>
    <content type="html"><![CDATA[<p>由於工作的需求越來越多，Ubuntu裝exe程式已經不敷使用。<br>開始了必須在Ubuntu上裝Windows系統的旅程。<br>小抱怨一下，越來越多的系統需求，但是處理器也不升級一下。<br>真的是越來越過份了/o\</p>
<p>正文開始</p>
<ol>
<li><p>首先必須到<a href="https://www.virtualbox.org/wiki/Linux_Downloads" target="_blank" rel="external">VirtualBox的官方網站</a>找自己適合的安裝檔，我的是<em>Ubuntu 12.04 LTS (“Precise Pangolin”)  i386 |  AMD64</em>這個版本。</p>
</li>
<li><p>cd到指定下載的資料夾(或你放置該檔案的其他位置)</p>
</li>
<li><p><code>sudo dpkg -i virtualbox-5.0_5.0.0-101573-Ubuntu-precise_amd64.deb(自己的檔案)</code></p>
</li>
<li><p>安裝好後，自行安裝想要的任何系統，Dowen是安裝 Windows 7。</p>
</li>
<li><p>假如以上沒有問題，就安裝好了，但是如果你遇上 VirtualBox error: Kernel driver not installed (rc=-1908)，那就請繼續往下看。</p>
</li>
<li><p>其實官方網站有說，為了防止Ubuntu有時後會不相容的問題，必須要安裝dkms所以就要使用以下的指令</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo aptitude <span class="operator"><span class="keyword">update</span></span><br><span class="line">sudo aptitude <span class="keyword">install</span> dkms</span><br><span class="line">sudo /etc/init.d/vboxdrv setup</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>這樣應該就沒什麼問題了，希望有幫到像我一樣苦惱的人。</p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>由於工作的需求越來越多，Ubuntu裝exe程式已經不敷使用。<br>開始了必須在Ubuntu上裝Windows系統的旅程。<br>小抱怨一下，越來越多的系統需求，但是處理器也不升級一下。<br>真的是越來越過份了/o\</p>
<p>正文開始</p>
<ol>
<li><]]>
    </summary>
    
      <category term="Ubuntu" scheme="http://tokenyet.github.io/tags/Ubuntu/"/>
    
      <category term="VirtualBox" scheme="http://tokenyet.github.io/tags/VirtualBox/"/>
    
      <category term="Linux" scheme="http://tokenyet.github.io/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[建立契機與為何使用Hexo？]]></title>
    <link href="http://tokenyet.github.io/2015/07/15/%E5%BB%BA%E7%AB%8B%E5%A5%91%E6%A9%9F%E8%88%87%E7%82%BA%E4%BD%95%E4%BD%BF%E7%94%A8Hexo%EF%BC%9F/"/>
    <id>http://tokenyet.github.io/2015/07/15/建立契機與為何使用Hexo？/</id>
    <published>2015-07-15T07:05:37.000Z</published>
    <updated>2015-07-15T13:22:04.995Z</updated>
    <content type="html"><![CDATA[<p>其實 Dowen 不像許多其他Hexo User一樣有許多的背景。像是從Wordpress或是Octopress之類的，<br>而且對網頁的知識也是不甚了解，但是偶然間逛到了<a href="http://morris821028.github.io/" target="_blank" rel="external">Morris</a>兄的網站。<br>一開始只是查作業系統而已，因為發現<a href="http://morris821028.github.io/" target="_blank" rel="external">Morris</a>兄擁有許多作業系統的好講義，為了考試來逛網站的次數久了後，不小撇了一下旁邊的頁面，發現文章真的都很有內容。</p>
<p>漸漸地，久違的哲學思考發作，為什麼他要這樣無私地奉獻自己的知識與技術呢？這樣作有什麼好處嗎？難道這又是一種OpenSource的概念嗎？接著靈光一閃，我有了自己的答案。</p>
<p>在這漫長的學習歲月中，常常因為學了又忘，忘了又學，在這累積知識的大起大落中徘徊不止，如果我能學習兼記錄並抓住那腦袋中忘卻曲線，那我<em>應該</em>能有所進步才對。在此這是我的答案，相信其他人或許是你都有自己建立的契機與動力。</p>
<p>想想以前，常常覺得知識是祕寶，不願與人分享的那段光陰，還真的是小心眼，沒有遠見。為此，我將我所知所得，慢慢的補記錄在本世界(網站)中。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>其實 Dowen 不像許多其他Hexo User一樣有許多的背景。像是從Wordpress或是Octopress之類的，<br>而且對網頁的知識也是不甚了解，但是偶然間逛到了<a href="http://morris821028.github.io/" target="_]]>
    </summary>
    
      <category term="Hexo" scheme="http://tokenyet.github.io/tags/Hexo/"/>
    
      <category term="網頁相關" scheme="http://tokenyet.github.io/categories/%E7%B6%B2%E9%A0%81%E7%9B%B8%E9%97%9C/"/>
    
  </entry>
  
</feed>
